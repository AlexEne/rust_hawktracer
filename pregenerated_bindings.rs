/* automatically generated by rust-bindgen */

pub const HT_VERSION : & 'static [ u8 ; 6usize ] = b"0.5.0\0" ; pub const HT_VERSION_MAJOR : u32 = 0 ; pub const HT_VERSION_MINOR : u32 = 5 ; pub const HT_VERSION_PATCH : u32 = 0 ; pub const _SAL_VERSION : u32 = 20 ; pub const __SAL_H_VERSION : u32 = 180000000 ; pub const _USE_DECLSPECS_FOR_SAL : u32 = 0 ; pub const _USE_ATTRIBUTES_FOR_SAL : u32 = 0 ; pub const _CRT_PACKING : u32 = 8 ; pub const _HAS_EXCEPTIONS : u32 = 1 ; pub const _ARGMAX : u32 = 100 ; pub const _CRT_INT_MAX : u32 = 2147483647 ; pub const _CRT_FUNCTIONS_REQUIRED : u32 = 1 ; pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE : u32 = 0 ; pub const _CRT_BUILD_DESKTOP_APP : u32 = 1 ; pub const __STDC_SECURE_LIB__ : u32 = 200411 ; pub const __GOT_SECURE_LIB__ : u32 = 200411 ; pub const __STDC_WANT_SECURE_LIB__ : u32 = 1 ; pub const _SECURECRT_FILL_BUFFER_PATTERN : u32 = 254 ; pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES : u32 = 0 ; pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT : u32 = 0 ; pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES : u32 = 1 ; pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY : u32 = 0 ; pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY : u32 = 0 ; pub const WCHAR_MIN : u32 = 0 ; pub const WCHAR_MAX : u32 = 65535 ; pub const WINT_MIN : u32 = 0 ; pub const WINT_MAX : u32 = 65535 ; pub const PRId8 : & 'static [ u8 ; 4usize ] = b"hhd\0" ; pub const PRId16 : & 'static [ u8 ; 3usize ] = b"hd\0" ; pub const PRId32 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRId64 : & 'static [ u8 ; 4usize ] = b"lld\0" ; pub const PRIdLEAST8 : & 'static [ u8 ; 4usize ] = b"hhd\0" ; pub const PRIdLEAST16 : & 'static [ u8 ; 3usize ] = b"hd\0" ; pub const PRIdLEAST32 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRIdLEAST64 : & 'static [ u8 ; 4usize ] = b"lld\0" ; pub const PRIdFAST8 : & 'static [ u8 ; 4usize ] = b"hhd\0" ; pub const PRIdFAST16 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRIdFAST32 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRIdFAST64 : & 'static [ u8 ; 4usize ] = b"lld\0" ; pub const PRIdMAX : & 'static [ u8 ; 4usize ] = b"lld\0" ; pub const PRIdPTR : & 'static [ u8 ; 4usize ] = b"lld\0" ; pub const PRIi8 : & 'static [ u8 ; 4usize ] = b"hhi\0" ; pub const PRIi16 : & 'static [ u8 ; 3usize ] = b"hi\0" ; pub const PRIi32 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIi64 : & 'static [ u8 ; 4usize ] = b"lli\0" ; pub const PRIiLEAST8 : & 'static [ u8 ; 4usize ] = b"hhi\0" ; pub const PRIiLEAST16 : & 'static [ u8 ; 3usize ] = b"hi\0" ; pub const PRIiLEAST32 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIiLEAST64 : & 'static [ u8 ; 4usize ] = b"lli\0" ; pub const PRIiFAST8 : & 'static [ u8 ; 4usize ] = b"hhi\0" ; pub const PRIiFAST16 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIiFAST32 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIiFAST64 : & 'static [ u8 ; 4usize ] = b"lli\0" ; pub const PRIiMAX : & 'static [ u8 ; 4usize ] = b"lli\0" ; pub const PRIiPTR : & 'static [ u8 ; 4usize ] = b"lli\0" ; pub const PRIo8 : & 'static [ u8 ; 4usize ] = b"hho\0" ; pub const PRIo16 : & 'static [ u8 ; 3usize ] = b"ho\0" ; pub const PRIo32 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIo64 : & 'static [ u8 ; 4usize ] = b"llo\0" ; pub const PRIoLEAST8 : & 'static [ u8 ; 4usize ] = b"hho\0" ; pub const PRIoLEAST16 : & 'static [ u8 ; 3usize ] = b"ho\0" ; pub const PRIoLEAST32 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIoLEAST64 : & 'static [ u8 ; 4usize ] = b"llo\0" ; pub const PRIoFAST8 : & 'static [ u8 ; 4usize ] = b"hho\0" ; pub const PRIoFAST16 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIoFAST32 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIoFAST64 : & 'static [ u8 ; 4usize ] = b"llo\0" ; pub const PRIoMAX : & 'static [ u8 ; 4usize ] = b"llo\0" ; pub const PRIoPTR : & 'static [ u8 ; 4usize ] = b"llo\0" ; pub const PRIu8 : & 'static [ u8 ; 4usize ] = b"hhu\0" ; pub const PRIu16 : & 'static [ u8 ; 3usize ] = b"hu\0" ; pub const PRIu32 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIu64 : & 'static [ u8 ; 4usize ] = b"llu\0" ; pub const PRIuLEAST8 : & 'static [ u8 ; 4usize ] = b"hhu\0" ; pub const PRIuLEAST16 : & 'static [ u8 ; 3usize ] = b"hu\0" ; pub const PRIuLEAST32 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIuLEAST64 : & 'static [ u8 ; 4usize ] = b"llu\0" ; pub const PRIuFAST8 : & 'static [ u8 ; 4usize ] = b"hhu\0" ; pub const PRIuFAST16 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIuFAST32 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIuFAST64 : & 'static [ u8 ; 4usize ] = b"llu\0" ; pub const PRIuMAX : & 'static [ u8 ; 4usize ] = b"llu\0" ; pub const PRIuPTR : & 'static [ u8 ; 4usize ] = b"llu\0" ; pub const PRIx8 : & 'static [ u8 ; 4usize ] = b"hhx\0" ; pub const PRIx16 : & 'static [ u8 ; 3usize ] = b"hx\0" ; pub const PRIx32 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIx64 : & 'static [ u8 ; 4usize ] = b"llx\0" ; pub const PRIxLEAST8 : & 'static [ u8 ; 4usize ] = b"hhx\0" ; pub const PRIxLEAST16 : & 'static [ u8 ; 3usize ] = b"hx\0" ; pub const PRIxLEAST32 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIxLEAST64 : & 'static [ u8 ; 4usize ] = b"llx\0" ; pub const PRIxFAST8 : & 'static [ u8 ; 4usize ] = b"hhx\0" ; pub const PRIxFAST16 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIxFAST32 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIxFAST64 : & 'static [ u8 ; 4usize ] = b"llx\0" ; pub const PRIxMAX : & 'static [ u8 ; 4usize ] = b"llx\0" ; pub const PRIxPTR : & 'static [ u8 ; 4usize ] = b"llx\0" ; pub const PRIX8 : & 'static [ u8 ; 4usize ] = b"hhX\0" ; pub const PRIX16 : & 'static [ u8 ; 3usize ] = b"hX\0" ; pub const PRIX32 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIX64 : & 'static [ u8 ; 4usize ] = b"llX\0" ; pub const PRIXLEAST8 : & 'static [ u8 ; 4usize ] = b"hhX\0" ; pub const PRIXLEAST16 : & 'static [ u8 ; 3usize ] = b"hX\0" ; pub const PRIXLEAST32 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIXLEAST64 : & 'static [ u8 ; 4usize ] = b"llX\0" ; pub const PRIXFAST8 : & 'static [ u8 ; 4usize ] = b"hhX\0" ; pub const PRIXFAST16 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIXFAST32 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIXFAST64 : & 'static [ u8 ; 4usize ] = b"llX\0" ; pub const PRIXMAX : & 'static [ u8 ; 4usize ] = b"llX\0" ; pub const PRIXPTR : & 'static [ u8 ; 4usize ] = b"llX\0" ; pub const SCNd8 : & 'static [ u8 ; 4usize ] = b"hhd\0" ; pub const SCNd16 : & 'static [ u8 ; 3usize ] = b"hd\0" ; pub const SCNd32 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const SCNd64 : & 'static [ u8 ; 4usize ] = b"lld\0" ; pub const SCNdLEAST8 : & 'static [ u8 ; 4usize ] = b"hhd\0" ; pub const SCNdLEAST16 : & 'static [ u8 ; 3usize ] = b"hd\0" ; pub const SCNdLEAST32 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const SCNdLEAST64 : & 'static [ u8 ; 4usize ] = b"lld\0" ; pub const SCNdFAST8 : & 'static [ u8 ; 4usize ] = b"hhd\0" ; pub const SCNdFAST16 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const SCNdFAST32 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const SCNdFAST64 : & 'static [ u8 ; 4usize ] = b"lld\0" ; pub const SCNdMAX : & 'static [ u8 ; 4usize ] = b"lld\0" ; pub const SCNdPTR : & 'static [ u8 ; 4usize ] = b"lld\0" ; pub const SCNi8 : & 'static [ u8 ; 4usize ] = b"hhi\0" ; pub const SCNi16 : & 'static [ u8 ; 3usize ] = b"hi\0" ; pub const SCNi32 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const SCNi64 : & 'static [ u8 ; 4usize ] = b"lli\0" ; pub const SCNiLEAST8 : & 'static [ u8 ; 4usize ] = b"hhi\0" ; pub const SCNiLEAST16 : & 'static [ u8 ; 3usize ] = b"hi\0" ; pub const SCNiLEAST32 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const SCNiLEAST64 : & 'static [ u8 ; 4usize ] = b"lli\0" ; pub const SCNiFAST8 : & 'static [ u8 ; 4usize ] = b"hhi\0" ; pub const SCNiFAST16 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const SCNiFAST32 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const SCNiFAST64 : & 'static [ u8 ; 4usize ] = b"lli\0" ; pub const SCNiMAX : & 'static [ u8 ; 4usize ] = b"lli\0" ; pub const SCNiPTR : & 'static [ u8 ; 4usize ] = b"lli\0" ; pub const SCNo8 : & 'static [ u8 ; 4usize ] = b"hho\0" ; pub const SCNo16 : & 'static [ u8 ; 3usize ] = b"ho\0" ; pub const SCNo32 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const SCNo64 : & 'static [ u8 ; 4usize ] = b"llo\0" ; pub const SCNoLEAST8 : & 'static [ u8 ; 4usize ] = b"hho\0" ; pub const SCNoLEAST16 : & 'static [ u8 ; 3usize ] = b"ho\0" ; pub const SCNoLEAST32 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const SCNoLEAST64 : & 'static [ u8 ; 4usize ] = b"llo\0" ; pub const SCNoFAST8 : & 'static [ u8 ; 4usize ] = b"hho\0" ; pub const SCNoFAST16 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const SCNoFAST32 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const SCNoFAST64 : & 'static [ u8 ; 4usize ] = b"llo\0" ; pub const SCNoMAX : & 'static [ u8 ; 4usize ] = b"llo\0" ; pub const SCNoPTR : & 'static [ u8 ; 4usize ] = b"llo\0" ; pub const SCNu8 : & 'static [ u8 ; 4usize ] = b"hhu\0" ; pub const SCNu16 : & 'static [ u8 ; 3usize ] = b"hu\0" ; pub const SCNu32 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const SCNu64 : & 'static [ u8 ; 4usize ] = b"llu\0" ; pub const SCNuLEAST8 : & 'static [ u8 ; 4usize ] = b"hhu\0" ; pub const SCNuLEAST16 : & 'static [ u8 ; 3usize ] = b"hu\0" ; pub const SCNuLEAST32 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const SCNuLEAST64 : & 'static [ u8 ; 4usize ] = b"llu\0" ; pub const SCNuFAST8 : & 'static [ u8 ; 4usize ] = b"hhu\0" ; pub const SCNuFAST16 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const SCNuFAST32 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const SCNuFAST64 : & 'static [ u8 ; 4usize ] = b"llu\0" ; pub const SCNuMAX : & 'static [ u8 ; 4usize ] = b"llu\0" ; pub const SCNuPTR : & 'static [ u8 ; 4usize ] = b"llu\0" ; pub const SCNx8 : & 'static [ u8 ; 4usize ] = b"hhx\0" ; pub const SCNx16 : & 'static [ u8 ; 3usize ] = b"hx\0" ; pub const SCNx32 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const SCNx64 : & 'static [ u8 ; 4usize ] = b"llx\0" ; pub const SCNxLEAST8 : & 'static [ u8 ; 4usize ] = b"hhx\0" ; pub const SCNxLEAST16 : & 'static [ u8 ; 3usize ] = b"hx\0" ; pub const SCNxLEAST32 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const SCNxLEAST64 : & 'static [ u8 ; 4usize ] = b"llx\0" ; pub const SCNxFAST8 : & 'static [ u8 ; 4usize ] = b"hhx\0" ; pub const SCNxFAST16 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const SCNxFAST32 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const SCNxFAST64 : & 'static [ u8 ; 4usize ] = b"llx\0" ; pub const SCNxMAX : & 'static [ u8 ; 4usize ] = b"llx\0" ; pub const SCNxPTR : & 'static [ u8 ; 4usize ] = b"llx\0" ; pub const HT_TRUE : u32 = 1 ; pub const HT_FALSE : u32 = 0 ; pub const HT_TIMELINE_MAX_FEATURES : u32 = 32 ; pub const EPERM : u32 = 1 ; pub const ENOENT : u32 = 2 ; pub const ESRCH : u32 = 3 ; pub const EINTR : u32 = 4 ; pub const EIO : u32 = 5 ; pub const ENXIO : u32 = 6 ; pub const E2BIG : u32 = 7 ; pub const ENOEXEC : u32 = 8 ; pub const EBADF : u32 = 9 ; pub const ECHILD : u32 = 10 ; pub const EAGAIN : u32 = 11 ; pub const ENOMEM : u32 = 12 ; pub const EACCES : u32 = 13 ; pub const EFAULT : u32 = 14 ; pub const EBUSY : u32 = 16 ; pub const EEXIST : u32 = 17 ; pub const EXDEV : u32 = 18 ; pub const ENODEV : u32 = 19 ; pub const ENOTDIR : u32 = 20 ; pub const EISDIR : u32 = 21 ; pub const ENFILE : u32 = 23 ; pub const EMFILE : u32 = 24 ; pub const ENOTTY : u32 = 25 ; pub const EFBIG : u32 = 27 ; pub const ENOSPC : u32 = 28 ; pub const ESPIPE : u32 = 29 ; pub const EROFS : u32 = 30 ; pub const EMLINK : u32 = 31 ; pub const EPIPE : u32 = 32 ; pub const EDOM : u32 = 33 ; pub const EDEADLK : u32 = 36 ; pub const ENAMETOOLONG : u32 = 38 ; pub const ENOLCK : u32 = 39 ; pub const ENOSYS : u32 = 40 ; pub const ENOTEMPTY : u32 = 41 ; pub const EINVAL : u32 = 22 ; pub const ERANGE : u32 = 34 ; pub const EILSEQ : u32 = 42 ; pub const STRUNCATE : u32 = 80 ; pub const EDEADLOCK : u32 = 36 ; pub const EADDRINUSE : u32 = 100 ; pub const EADDRNOTAVAIL : u32 = 101 ; pub const EAFNOSUPPORT : u32 = 102 ; pub const EALREADY : u32 = 103 ; pub const EBADMSG : u32 = 104 ; pub const ECANCELED : u32 = 105 ; pub const ECONNABORTED : u32 = 106 ; pub const ECONNREFUSED : u32 = 107 ; pub const ECONNRESET : u32 = 108 ; pub const EDESTADDRREQ : u32 = 109 ; pub const EHOSTUNREACH : u32 = 110 ; pub const EIDRM : u32 = 111 ; pub const EINPROGRESS : u32 = 112 ; pub const EISCONN : u32 = 113 ; pub const ELOOP : u32 = 114 ; pub const EMSGSIZE : u32 = 115 ; pub const ENETDOWN : u32 = 116 ; pub const ENETRESET : u32 = 117 ; pub const ENETUNREACH : u32 = 118 ; pub const ENOBUFS : u32 = 119 ; pub const ENODATA : u32 = 120 ; pub const ENOLINK : u32 = 121 ; pub const ENOMSG : u32 = 122 ; pub const ENOPROTOOPT : u32 = 123 ; pub const ENOSR : u32 = 124 ; pub const ENOSTR : u32 = 125 ; pub const ENOTCONN : u32 = 126 ; pub const ENOTRECOVERABLE : u32 = 127 ; pub const ENOTSOCK : u32 = 128 ; pub const ENOTSUP : u32 = 129 ; pub const EOPNOTSUPP : u32 = 130 ; pub const EOTHER : u32 = 131 ; pub const EOVERFLOW : u32 = 132 ; pub const EOWNERDEAD : u32 = 133 ; pub const EPROTO : u32 = 134 ; pub const EPROTONOSUPPORT : u32 = 135 ; pub const EPROTOTYPE : u32 = 136 ; pub const ETIME : u32 = 137 ; pub const ETIMEDOUT : u32 = 138 ; pub const ETXTBSY : u32 = 139 ; pub const EWOULDBLOCK : u32 = 140 ; pub const _NLSCMPERROR : u32 = 2147483647 ; pub const HT_FEATURE_CACHED_STRING : u32 = 1 ; pub const HT_FEATURE_CALLSTACK : u32 = 0 ; pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX : & 'static [ u8 ; 1usize ] = b"\0" ; pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION : u32 = 1 ; pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR : u32 = 2 ; pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS : u32 = 4 ; pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY : u32 = 8 ; pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS : u32 = 16 ; pub const _CRT_INTERNAL_SCANF_SECURECRT : u32 = 1 ; pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS : u32 = 2 ; pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY : u32 = 4 ; pub const BUFSIZ : u32 = 512 ; pub const _NSTREAM_ : u32 = 512 ; pub const _IOB_ENTRIES : u32 = 3 ; pub const EOF : i32 = -1 ; pub const _IOFBF : u32 = 0 ; pub const _IOLBF : u32 = 64 ; pub const _IONBF : u32 = 4 ; pub const L_tmpnam : u32 = 260 ; pub const L_tmpnam_s : u32 = 260 ; pub const SEEK_CUR : u32 = 1 ; pub const SEEK_END : u32 = 2 ; pub const SEEK_SET : u32 = 0 ; pub const FILENAME_MAX : u32 = 260 ; pub const FOPEN_MAX : u32 = 20 ; pub const _SYS_OPEN : u32 = 20 ; pub const TMP_MAX : u32 = 2147483647 ; pub const TMP_MAX_S : u32 = 2147483647 ; pub const _TMP_MAX_S : u32 = 2147483647 ; pub const SYS_OPEN : u32 = 20 ; pub type wchar_t = :: std :: os :: raw :: c_ushort ; 
 /// Callback function for a custom allocator.
///
/// HawkTracer requires only one function, which depending on
/// parameter values, performs: alloc, free, and realloc operations.
///
/// To allocate memory, @p ptr must be NULL.
/// To free memory, @p size must be equal to 0.
/// To realloc memory, @p size must be greater than 0, and @p ptr must not
/// be NULL.
///
/// @param ptr a pointer to a memory block for alloc/realloc/free operations.
/// @param size a size of memory block to allocate for alloc/realloc operations.
/// @param user_data an user data specified in ht_allocator_set().
///
/// @return a pointer to allocated memory block for alloc/realloc operations. 
 pub type realloc_function = :: std :: option :: Option < unsafe extern "C" fn ( ptr : * mut :: std :: os :: raw :: c_void , size : usize , user_data : * mut :: std :: os :: raw :: c_void ) -> * mut :: std :: os :: raw :: c_void > ; extern "C" { 
 /// Sets a global allocator for HawkTracer library.
///
/// The allocator is used for every allocation in the library. The function
/// must be called before ht_init() function call.
/// If custom allocator is not specified, default allocator will be used.
///
/// @param func an allocation function.
/// @param user_data an opaque pointer passed to the allocator as a last argument. 
 pub fn ht_allocator_set ( func : realloc_function , user_data : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { 
 /// Allocates memory using HawkTracer allocator.
///
/// @param size a number of bytes to allocate.
///
/// @return a pointer to allocated memory. 
 pub fn ht_alloc ( size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { 
 /// Changes the size of the memory block.
///
/// @param ptr a pointer to the memory block.
/// @param size new size of the memory block.
///
/// @return a pointer to reallocated memory. 
 pub fn ht_realloc ( ptr : * mut :: std :: os :: raw :: c_void , size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { 
 /// Releases memory allocated by ht_alloc.
///
/// @param ptr a pointer to the memory block to release. 
 pub fn ht_free ( ptr : * mut :: std :: os :: raw :: c_void ) ; } pub type va_list = * mut :: std :: os :: raw :: c_char ; extern "C" { pub fn __va_start ( arg1 : * mut va_list , ... ) ; } pub type __vcrt_bool = bool ; extern "C" { pub fn __security_init_cookie ( ) ; } extern "C" { pub fn __security_check_cookie ( _StackCookie : usize ) ; } extern "C" { pub fn __report_gsfailure ( _StackCookie : usize ) ; } extern "C" { # [ link_name = "\u{1}__security_cookie" ] pub static mut __security_cookie : usize ; } pub type __crt_bool = bool ; extern "C" { pub fn _invalid_parameter_noinfo ( ) ; } extern "C" { pub fn _invalid_parameter_noinfo_noreturn ( ) ; } extern "C" { pub fn _invoke_watson ( _Expression : * const wchar_t , _FunctionName : * const wchar_t , _FileName : * const wchar_t , _LineNo : :: std :: os :: raw :: c_uint , _Reserved : usize ) ; } pub type errno_t = :: std :: os :: raw :: c_int ; pub type wint_t = :: std :: os :: raw :: c_ushort ; pub type wctype_t = :: std :: os :: raw :: c_ushort ; pub type __time32_t = :: std :: os :: raw :: c_long ; pub type __time64_t = :: std :: os :: raw :: c_longlong ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __crt_locale_data_public { pub _locale_pctype : * const :: std :: os :: raw :: c_ushort , pub _locale_mb_cur_max : :: std :: os :: raw :: c_int , pub _locale_lc_codepage : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout___crt_locale_data_public ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __crt_locale_data_public > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __crt_locale_data_public ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __crt_locale_data_public > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __crt_locale_data_public ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __crt_locale_data_public > ( ) ) ) . _locale_pctype as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __crt_locale_data_public ) , "::" , stringify ! ( _locale_pctype ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __crt_locale_data_public > ( ) ) ) . _locale_mb_cur_max as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __crt_locale_data_public ) , "::" , stringify ! ( _locale_mb_cur_max ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __crt_locale_data_public > ( ) ) ) . _locale_lc_codepage as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( __crt_locale_data_public ) , "::" , stringify ! ( _locale_lc_codepage ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __crt_locale_pointers { pub locinfo : * mut __crt_locale_data , pub mbcinfo : * mut __crt_multibyte_data , } # [ test ] fn bindgen_test_layout___crt_locale_pointers ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __crt_locale_pointers > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __crt_locale_pointers ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __crt_locale_pointers > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __crt_locale_pointers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __crt_locale_pointers > ( ) ) ) . locinfo as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __crt_locale_pointers ) , "::" , stringify ! ( locinfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __crt_locale_pointers > ( ) ) ) . mbcinfo as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __crt_locale_pointers ) , "::" , stringify ! ( mbcinfo ) ) ) ; } pub type _locale_t = * mut __crt_locale_pointers ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _Mbstatet { pub _Wchar : :: std :: os :: raw :: c_ulong , pub _Byte : :: std :: os :: raw :: c_ushort , pub _State : :: std :: os :: raw :: c_ushort , } # [ test ] fn bindgen_test_layout__Mbstatet ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _Mbstatet > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( _Mbstatet ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _Mbstatet > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( _Mbstatet ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _Mbstatet > ( ) ) ) . _Wchar as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _Mbstatet ) , "::" , stringify ! ( _Wchar ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _Mbstatet > ( ) ) ) . _Byte as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( _Mbstatet ) , "::" , stringify ! ( _Byte ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _Mbstatet > ( ) ) ) . _State as * const _ as usize } , 6usize , concat ! ( "Offset of field: " , stringify ! ( _Mbstatet ) , "::" , stringify ! ( _State ) ) ) ; } pub type mbstate_t = _Mbstatet ; pub type time_t = __time64_t ; pub type rsize_t = usize ; pub type int_least8_t = :: std :: os :: raw :: c_schar ; pub type int_least16_t = :: std :: os :: raw :: c_short ; pub type int_least32_t = :: std :: os :: raw :: c_int ; pub type int_least64_t = :: std :: os :: raw :: c_longlong ; pub type uint_least8_t = :: std :: os :: raw :: c_uchar ; pub type uint_least16_t = :: std :: os :: raw :: c_ushort ; pub type uint_least32_t = :: std :: os :: raw :: c_uint ; pub type uint_least64_t = :: std :: os :: raw :: c_ulonglong ; pub type int_fast8_t = :: std :: os :: raw :: c_schar ; pub type int_fast16_t = :: std :: os :: raw :: c_int ; pub type int_fast32_t = :: std :: os :: raw :: c_int ; pub type int_fast64_t = :: std :: os :: raw :: c_longlong ; pub type uint_fast8_t = :: std :: os :: raw :: c_uchar ; pub type uint_fast16_t = :: std :: os :: raw :: c_uint ; pub type uint_fast32_t = :: std :: os :: raw :: c_uint ; pub type uint_fast64_t = :: std :: os :: raw :: c_ulonglong ; pub type intmax_t = :: std :: os :: raw :: c_longlong ; pub type uintmax_t = :: std :: os :: raw :: c_ulonglong ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _Lldiv_t { pub quot : intmax_t , pub rem : intmax_t , } # [ test ] fn bindgen_test_layout__Lldiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _Lldiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _Lldiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _Lldiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _Lldiv_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _Lldiv_t > ( ) ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _Lldiv_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _Lldiv_t > ( ) ) ) . rem as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _Lldiv_t ) , "::" , stringify ! ( rem ) ) ) ; } pub type imaxdiv_t = _Lldiv_t ; extern "C" { pub fn imaxabs ( _Number : intmax_t ) -> intmax_t ; } extern "C" { pub fn imaxdiv ( _Numerator : intmax_t , _Denominator : intmax_t ) -> imaxdiv_t ; } extern "C" { pub fn strtoimax ( _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int ) -> intmax_t ; } extern "C" { pub fn _strtoimax_l ( _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> intmax_t ; } extern "C" { pub fn strtoumax ( _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int ) -> uintmax_t ; } extern "C" { pub fn _strtoumax_l ( _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> uintmax_t ; } extern "C" { pub fn wcstoimax ( _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int ) -> intmax_t ; } extern "C" { pub fn _wcstoimax_l ( _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> intmax_t ; } extern "C" { pub fn wcstoumax ( _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int ) -> uintmax_t ; } extern "C" { pub fn _wcstoumax_l ( _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t ) -> uintmax_t ; } 
 /// An unsigned integer used for event klass identifiers. 
 pub type HT_EventKlassId = u32 ; 
 /// An unsigned integer used for representing timestamps in nanoseconds. 
 pub type HT_TimestampNs = u64 ; 
 /// An unsigned integer used for event identifiers. 
 pub type HT_EventId = u64 ; 
 /// An unsigned integer used for representing duration in nanoseconds. 
 pub type HT_DurationNs = u64 ; 
 /// A standard boolean type, possible values: #HT_TRUE, #HT_FALSE 
 pub type HT_Boolean = :: std :: os :: raw :: c_int ; 
 /// A pointer to a list of HT_Event (or derived) objects. 
 pub type TEventPtr = * mut u8 ; 
 /// An unsigned integer used for thread identifiers. 
 pub type HT_ThreadId = u32 ; 
 /// An unsigned integer guaranteed to be 8 bits on all platforms. 
 pub type HT_Byte = u8 ; 
 /// No error 
 pub const HT_ErrorCode_HT_ERR_OK : HT_ErrorCode = 0 ; 
 /// Memory allocation failed. This is very serious error, and
/// most likely your entire application is broken at this point of time. 
 pub const HT_ErrorCode_HT_ERR_OUT_OF_MEMORY : HT_ErrorCode = 1 ; 
 /// Try to register a timeline feature using ID which is already taken
/// by some other feature. 
 pub const HT_ErrorCode_HT_ERR_FEATURE_ALREADY_REGISTERED : HT_ErrorCode = 2 ; 
 /// Try to register container with name already used in registry.
/// This error is used internally, and is never returned by public
/// API. TODO: consider removing it from public enum. 
 pub const HT_ErrorCode_HT_ERR_LISTENER_CONTAINER_ALREADY_REGISTERED : HT_ErrorCode = 3 ; 
 /// Cannot open file. 
 pub const HT_ErrorCode_HT_ERR_CANT_OPEN_FILE : HT_ErrorCode = 4 ; 
 /// Cannot start tcp server. This error might have many root causes,
/// some of them are: socket can't be open, library is not able to bind to a port. 
 pub const HT_ErrorCode_HT_ERR_CANT_START_TCP_SERVER : HT_ErrorCode = 5 ; 
 /// Unable to create listener container. This is most likely caused by
/// #HT_ERR_OUT_OF_MEMORY occured internally in the library. 
 pub const HT_ErrorCode_HT_ERR_CANT_CREATE_LISTENER_CONTAINER : HT_ErrorCode = 6 ; 
 /// Defines list of possible errors returned by library functions. 
 pub type HT_ErrorCode = i32 ; pub const MKCREFLECT_Types_MKCREFLECT_TYPES_STRUCT : MKCREFLECT_Types = 1 ; pub const MKCREFLECT_Types_MKCREFLECT_TYPES_STRING : MKCREFLECT_Types = 2 ; pub const MKCREFLECT_Types_MKCREFLECT_TYPES_INTEGER : MKCREFLECT_Types = 3 ; pub const MKCREFLECT_Types_MKCREFLECT_TYPES_FLOAT : MKCREFLECT_Types = 4 ; pub const MKCREFLECT_Types_MKCREFLECT_TYPES_DOUBLE : MKCREFLECT_Types = 5 ; pub const MKCREFLECT_Types_MKCREFLECT_TYPES_POINTER : MKCREFLECT_Types = 6 ; pub type MKCREFLECT_Types = i32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _MKCREFLECT_FieldInfo { pub field_type : * const :: std :: os :: raw :: c_char , pub field_name : * const :: std :: os :: raw :: c_char , pub size : usize , pub offset : usize , pub is_signed : :: std :: os :: raw :: c_int , pub array_size : :: std :: os :: raw :: c_int , pub data_type : MKCREFLECT_Types , } # [ test ] fn bindgen_test_layout__MKCREFLECT_FieldInfo ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _MKCREFLECT_FieldInfo > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( _MKCREFLECT_FieldInfo ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _MKCREFLECT_FieldInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _MKCREFLECT_FieldInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_FieldInfo > ( ) ) ) . field_type as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_FieldInfo ) , "::" , stringify ! ( field_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_FieldInfo > ( ) ) ) . field_name as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_FieldInfo ) , "::" , stringify ! ( field_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_FieldInfo > ( ) ) ) . size as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_FieldInfo ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_FieldInfo > ( ) ) ) . offset as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_FieldInfo ) , "::" , stringify ! ( offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_FieldInfo > ( ) ) ) . is_signed as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_FieldInfo ) , "::" , stringify ! ( is_signed ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_FieldInfo > ( ) ) ) . array_size as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_FieldInfo ) , "::" , stringify ! ( array_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_FieldInfo > ( ) ) ) . data_type as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_FieldInfo ) , "::" , stringify ! ( data_type ) ) ) ; } pub type MKCREFLECT_FieldInfo = _MKCREFLECT_FieldInfo ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _MKCREFLECT_TypeInfo { pub name : * const :: std :: os :: raw :: c_char , pub fields_count : usize , pub size : usize , pub packed_size : usize , pub fields : * mut MKCREFLECT_FieldInfo , } # [ test ] fn bindgen_test_layout__MKCREFLECT_TypeInfo ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _MKCREFLECT_TypeInfo > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( _MKCREFLECT_TypeInfo ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _MKCREFLECT_TypeInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _MKCREFLECT_TypeInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_TypeInfo > ( ) ) ) . name as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_TypeInfo ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_TypeInfo > ( ) ) ) . fields_count as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_TypeInfo ) , "::" , stringify ! ( fields_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_TypeInfo > ( ) ) ) . size as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_TypeInfo ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_TypeInfo > ( ) ) ) . packed_size as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_TypeInfo ) , "::" , stringify ! ( packed_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_TypeInfo > ( ) ) ) . fields as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_TypeInfo ) , "::" , stringify ! ( fields ) ) ) ; } pub type MKCREFLECT_TypeInfo = _MKCREFLECT_TypeInfo ; pub type HT_EventKlass = _HT_EventKlass ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HT_Event { pub klass : * mut HT_EventKlass , pub timestamp : HT_TimestampNs , pub id : HT_EventId , } # [ test ] fn bindgen_test_layout_HT_Event ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HT_Event > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( HT_Event ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HT_Event > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( HT_Event ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_Event > ( ) ) ) . klass as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HT_Event ) , "::" , stringify ! ( klass ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_Event > ( ) ) ) . timestamp as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( HT_Event ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_Event > ( ) ) ) . id as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( HT_Event ) , "::" , stringify ! ( id ) ) ) ; } extern "C" { pub fn mkcreflect_get_HT_Event_type_info ( ) -> * mut MKCREFLECT_TypeInfo ; } extern "C" { pub fn ht_HT_Event_get_event_klass_instance ( ) -> * mut HT_EventKlass ; } extern "C" { pub fn ht_HT_Event_register_event_klass ( ) -> HT_EventKlassId ; } extern "C" { pub fn ht_HT_Event_get_size ( event : * mut HT_Event ) -> usize ; } extern "C" { pub fn ht_HT_Event_fnc_serialize ( event : * mut HT_Event , buffer : * mut HT_Byte ) -> usize ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _HT_EventKlass { pub type_info : * mut MKCREFLECT_TypeInfo , pub serialize : :: std :: option :: Option < unsafe extern "C" fn ( event : * mut HT_Event , buffer : * mut HT_Byte ) -> usize > , pub get_size : :: std :: option :: Option < unsafe extern "C" fn ( event : * mut HT_Event ) -> usize > , pub klass_id : HT_EventKlassId , } # [ test ] fn bindgen_test_layout__HT_EventKlass ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _HT_EventKlass > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( _HT_EventKlass ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _HT_EventKlass > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _HT_EventKlass ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _HT_EventKlass > ( ) ) ) . type_info as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _HT_EventKlass ) , "::" , stringify ! ( type_info ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _HT_EventKlass > ( ) ) ) . serialize as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _HT_EventKlass ) , "::" , stringify ! ( serialize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _HT_EventKlass > ( ) ) ) . get_size as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _HT_EventKlass ) , "::" , stringify ! ( get_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _HT_EventKlass > ( ) ) ) . klass_id as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _HT_EventKlass ) , "::" , stringify ! ( klass_id ) ) ) ; } extern "C" { 
 /// Gets a current timestamp of a monotonic clock.
///
/// The timestamp of this clock can not decrease as physical
/// time moves forward. Although the timestamp doesn't represent wall
/// clock time, returned values can be used e.g. for measuring
/// intervals.
///
/// @return a current timestamp of the clock. 
 pub fn ht_monotonic_clock_get_timestamp ( ) -> HT_TimestampNs ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _HT_TimelineListenerContainer { _unused : [ u8 ; 0 ] , } pub type HT_TimelineListenerContainer = _HT_TimelineListenerContainer ; pub type HT_TimelineListenerCallback = :: std :: option :: Option < unsafe extern "C" fn ( events : TEventPtr , event_count : usize , serialized : HT_Boolean , user_data : * mut :: std :: os :: raw :: c_void ) > ; extern "C" { pub fn ht_timeline_listener_container_create ( ) -> * mut HT_TimelineListenerContainer ; } extern "C" { pub fn ht_timeline_listener_container_unref ( container : * mut HT_TimelineListenerContainer ) ; } extern "C" { 
 /// Registers new listener to a container.
///
/// @param container a pointer to the container.
/// @param callback a timeline listener callback.
/// @param user_data a user data passed to a @a callback when gets called.
///
/// @returns #HT_ERR_OK, if registration completed successfully; otherwise, appropriate error code. 
 pub fn ht_timeline_listener_container_register_listener ( container : * mut HT_TimelineListenerContainer , callback : HT_TimelineListenerCallback , user_data : * mut :: std :: os :: raw :: c_void ) -> HT_ErrorCode ; } extern "C" { 
 /// Removes all timeline listeners from the container.
///
/// @param container a pointer to the container. 
 pub fn ht_timeline_listener_container_unregister_all_listeners ( container : * mut HT_TimelineListenerContainer ) ; } extern "C" { 
 /// Finds an container in a global registry or create one if container doesn't exist.
///
/// If @a name is NULL, this method always returns new container.
///
/// @param name a name of the container to find/create.
///
/// @return a pointer to a container. 
 pub fn ht_find_or_create_listener ( name : * const :: std :: os :: raw :: c_char ) -> * mut HT_TimelineListenerContainer ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _HT_EventIdProvider { _unused : [ u8 ; 0 ] , } 
 /// HT_EventIdProvider is a sequence number generator. It starts
/// the sequence from 0. Every next call of ht_event_id_provider_next()
/// increments the identifier. 
 pub type HT_EventIdProvider = _HT_EventIdProvider ; extern "C" { 
 /// Gets default provider.
///
/// Default ID provider is currently used for all the timelines.
///
/// @return a pointer to the default ID provider. 
 pub fn ht_event_id_provider_get_default ( ) -> * mut HT_EventIdProvider ; } extern "C" { 
 /// Creates a new instance of an ID provider.
///
/// @return a pointer to the new ID provider. 
 pub fn ht_event_id_provider_create ( ) -> * mut HT_EventIdProvider ; } extern "C" { 
 /// Destroys a provider.
/// @param provider a provider to destroy. 
 pub fn ht_event_id_provider_destroy ( provider : * mut HT_EventIdProvider ) ; } extern "C" { 
 /// Gets next identifier.
///
/// @param provider a provider.
///
/// @return next identifier from the @p provider. 
 pub fn ht_event_id_provider_next ( provider : * mut HT_EventIdProvider ) -> HT_EventId ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _HT_Timeline { _unused : [ u8 ; 0 ] , } pub type HT_Timeline = _HT_Timeline ; extern "C" { pub fn ht_timeline_create ( buffer_capacity : usize , thread_safe : HT_Boolean , serialize_events : HT_Boolean , listeners : * const :: std :: os :: raw :: c_char , out_err : * mut HT_ErrorCode ) -> * mut HT_Timeline ; } extern "C" { pub fn ht_timeline_destroy ( timeline : * mut HT_Timeline ) ; } extern "C" { pub fn ht_timeline_register_listener ( timeline : * mut HT_Timeline , callback : HT_TimelineListenerCallback , user_data : * mut :: std :: os :: raw :: c_void ) -> HT_ErrorCode ; } extern "C" { pub fn ht_timeline_unregister_all_listeners ( timeline : * mut HT_Timeline ) ; } extern "C" { pub fn ht_timeline_init_event ( timeline : * mut HT_Timeline , event : * mut HT_Event ) ; } extern "C" { pub fn ht_timeline_push_event ( timeline : * mut HT_Timeline , event : * mut HT_Event ) ; } extern "C" { pub fn ht_timeline_flush ( timeline : * mut HT_Timeline ) ; } extern "C" { pub fn ht_timeline_set_feature ( timeline : * mut HT_Timeline , feature_id : usize , feature : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { pub fn ht_timeline_get_feature ( timeline : * mut HT_Timeline , feature_id : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn ht_timeline_get_id_provider ( timeline : * mut HT_Timeline ) -> * mut HT_EventIdProvider ; } 
 /// A type of a callback which gets called when a timeline disables the feature. 
 pub type HT_FeatureDisableCallback = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut HT_Timeline ) > ; extern "C" { 
 /// Registers new a new feature in the system.
///
/// @param feature_id a feature identifier.
/// @param disable_callback a function which gets called when timeline disables the feature.
///
/// @returns #HT_ERR_OK, if registration completed successfully; otherwise, appropriate error code. 
 pub fn ht_registry_register_feature ( feature_id : u32 , disable_callback : HT_FeatureDisableCallback ) -> HT_ErrorCode ; } extern "C" { 
 /// Registers new event klass in the system, or gets identifier if klass is already registered.
///
/// @param event_klass a pointer to a klass definition.
///
/// @return an identifier to a klass, or #HT_INVALID_KLASS_ID if registration failed. 
 pub fn ht_registry_register_event_klass ( event_klass : * mut HT_EventKlass ) -> HT_EventKlassId ; } extern "C" { 
 /// Pushes HT_EventKlassInfoEvent and HT_EventKlassFieldInfoEvent events to a timeline which contain a definition of the klass.
///
/// @param timeline the timeline where events are pushed to.
/// @param klass a pointer to the klass. 
 pub fn ht_registry_push_klass_info_event ( timeline : * mut HT_Timeline , klass : * mut HT_EventKlass ) ; } extern "C" { 
 /// Pushes HT_EventKlassInfoEvent and HT_EventKlassFieldInfoEvent events to a timeline which contain definitions of all registered klasses.
///
/// @param timeline the timeline where events are pushed to. 
 pub fn ht_registry_push_all_klass_info_events ( timeline : * mut HT_Timeline ) ; } extern "C" { pub fn ht_registry_get_event_klasses ( out_klass_count : * mut usize ) -> * mut * mut HT_EventKlass ; } extern "C" { pub fn _errno ( ) -> * mut :: std :: os :: raw :: c_int ; } extern "C" { pub fn _set_errno ( _Value : :: std :: os :: raw :: c_int ) -> errno_t ; } extern "C" { pub fn _get_errno ( _Value : * mut :: std :: os :: raw :: c_int ) -> errno_t ; } extern "C" { pub fn __doserrno ( ) -> * mut :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn _set_doserrno ( _Value : :: std :: os :: raw :: c_ulong ) -> errno_t ; } extern "C" { pub fn _get_doserrno ( _Value : * mut :: std :: os :: raw :: c_ulong ) -> errno_t ; } extern "C" { pub fn memchr ( _Buf : * const :: std :: os :: raw :: c_void , _Val : :: std :: os :: raw :: c_int , _MaxCount : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memcmp ( _Buf1 : * const :: std :: os :: raw :: c_void , _Buf2 : * const :: std :: os :: raw :: c_void , _Size : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn memcpy ( _Dst : * mut :: std :: os :: raw :: c_void , _Src : * const :: std :: os :: raw :: c_void , _Size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memmove ( _Dst : * mut :: std :: os :: raw :: c_void , _Src : * const :: std :: os :: raw :: c_void , _Size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memset ( _Dst : * mut :: std :: os :: raw :: c_void , _Val : :: std :: os :: raw :: c_int , _Size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn strchr ( _Str : * const :: std :: os :: raw :: c_char , _Val : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strrchr ( _Str : * const :: std :: os :: raw :: c_char , _Ch : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strstr ( _Str : * const :: std :: os :: raw :: c_char , _SubStr : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn wcschr ( _Str : * const wchar_t , _Ch : wchar_t ) -> * mut :: std :: os :: raw :: c_ushort ; } extern "C" { pub fn wcsrchr ( _Str : * const wchar_t , _Ch : wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcsstr ( _Str : * const wchar_t , _SubStr : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn _memicmp ( _Buf1 : * const :: std :: os :: raw :: c_void , _Buf2 : * const :: std :: os :: raw :: c_void , _Size : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _memicmp_l ( _Buf1 : * const :: std :: os :: raw :: c_void , _Buf2 : * const :: std :: os :: raw :: c_void , _Size : usize , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn memccpy ( _Dst : * mut :: std :: os :: raw :: c_void , _Src : * const :: std :: os :: raw :: c_void , _Val : :: std :: os :: raw :: c_int , _Size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memicmp ( _Buf1 : * const :: std :: os :: raw :: c_void , _Buf2 : * const :: std :: os :: raw :: c_void , _Size : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn wcscat_s ( _Destination : * mut wchar_t , _SizeInWords : rsize_t , _Source : * const wchar_t ) -> errno_t ; } extern "C" { pub fn wcscpy_s ( _Destination : * mut wchar_t , _SizeInWords : rsize_t , _Source : * const wchar_t ) -> errno_t ; } extern "C" { pub fn wcsncat_s ( _Destination : * mut wchar_t , _SizeInWords : rsize_t , _Source : * const wchar_t , _MaxCount : rsize_t ) -> errno_t ; } extern "C" { pub fn wcsncpy_s ( _Destination : * mut wchar_t , _SizeInWords : rsize_t , _Source : * const wchar_t , _MaxCount : rsize_t ) -> errno_t ; } extern "C" { pub fn wcstok_s ( _String : * mut wchar_t , _Delimiter : * const wchar_t , _Context : * mut * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn _wcsdup ( _String : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcscat ( _Destination : * mut wchar_t , _Source : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcscmp ( _String1 : * const wchar_t , _String2 : * const wchar_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn wcscpy ( _Destination : * mut wchar_t , _Source : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcscspn ( _String : * const wchar_t , _Control : * const wchar_t ) -> usize ; } extern "C" { pub fn wcslen ( _String : * const wchar_t ) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { pub fn wcsnlen ( _Source : * const wchar_t , _MaxCount : usize ) -> usize ; } extern "C" { pub fn wcsncat ( _Destination : * mut wchar_t , _Source : * const wchar_t , _Count : usize ) -> * mut wchar_t ; } extern "C" { pub fn wcsncmp ( _String1 : * const wchar_t , _String2 : * const wchar_t , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn wcsncpy ( _Destination : * mut wchar_t , _Source : * const wchar_t , _Count : usize ) -> * mut wchar_t ; } extern "C" { pub fn wcspbrk ( _String : * const wchar_t , _Control : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcsspn ( _String : * const wchar_t , _Control : * const wchar_t ) -> usize ; } extern "C" { pub fn wcstok ( _String : * mut wchar_t , _Delimiter : * const wchar_t , _Context : * mut * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn _wcserror ( _ErrorNumber : :: std :: os :: raw :: c_int ) -> * mut wchar_t ; } extern "C" { pub fn _wcserror_s ( _Buffer : * mut wchar_t , _SizeInWords : usize , _ErrorNumber : :: std :: os :: raw :: c_int ) -> errno_t ; } extern "C" { pub fn __wcserror ( _String : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn __wcserror_s ( _Buffer : * mut wchar_t , _SizeInWords : usize , _ErrorMessage : * const wchar_t ) -> errno_t ; } extern "C" { pub fn _wcsicmp ( _String1 : * const wchar_t , _String2 : * const wchar_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsicmp_l ( _String1 : * const wchar_t , _String2 : * const wchar_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsnicmp ( _String1 : * const wchar_t , _String2 : * const wchar_t , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsnicmp_l ( _String1 : * const wchar_t , _String2 : * const wchar_t , _MaxCount : usize , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsnset_s ( _Destination : * mut wchar_t , _SizeInWords : usize , _Value : wchar_t , _MaxCount : usize ) -> errno_t ; } extern "C" { pub fn _wcsnset ( _String : * mut wchar_t , _Value : wchar_t , _MaxCount : usize ) -> * mut wchar_t ; } extern "C" { pub fn _wcsrev ( _String : * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn _wcsset_s ( _Destination : * mut wchar_t , _SizeInWords : usize , _Value : wchar_t ) -> errno_t ; } extern "C" { pub fn _wcsset ( _String : * mut wchar_t , _Value : wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn _wcslwr_s ( _String : * mut wchar_t , _SizeInWords : usize ) -> errno_t ; } extern "C" { pub fn _wcslwr ( _String : * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn _wcslwr_s_l ( _String : * mut wchar_t , _SizeInWords : usize , _Locale : _locale_t ) -> errno_t ; } extern "C" { pub fn _wcslwr_l ( _String : * mut wchar_t , _Locale : _locale_t ) -> * mut wchar_t ; } extern "C" { pub fn _wcsupr_s ( _String : * mut wchar_t , _Size : usize ) -> errno_t ; } extern "C" { pub fn _wcsupr ( _String : * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn _wcsupr_s_l ( _String : * mut wchar_t , _Size : usize , _Locale : _locale_t ) -> errno_t ; } extern "C" { pub fn _wcsupr_l ( _String : * mut wchar_t , _Locale : _locale_t ) -> * mut wchar_t ; } extern "C" { pub fn wcsxfrm ( _Destination : * mut wchar_t , _Source : * const wchar_t , _MaxCount : usize ) -> usize ; } extern "C" { pub fn _wcsxfrm_l ( _Destination : * mut wchar_t , _Source : * const wchar_t , _MaxCount : usize , _Locale : _locale_t ) -> usize ; } extern "C" { pub fn wcscoll ( _String1 : * const wchar_t , _String2 : * const wchar_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcscoll_l ( _String1 : * const wchar_t , _String2 : * const wchar_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsicoll ( _String1 : * const wchar_t , _String2 : * const wchar_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsicoll_l ( _String1 : * const wchar_t , _String2 : * const wchar_t , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsncoll ( _String1 : * const wchar_t , _String2 : * const wchar_t , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsncoll_l ( _String1 : * const wchar_t , _String2 : * const wchar_t , _MaxCount : usize , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsnicoll ( _String1 : * const wchar_t , _String2 : * const wchar_t , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wcsnicoll_l ( _String1 : * const wchar_t , _String2 : * const wchar_t , _MaxCount : usize , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn wcsdup ( _String : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcsicmp ( _String1 : * const wchar_t , _String2 : * const wchar_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn wcsnicmp ( _String1 : * const wchar_t , _String2 : * const wchar_t , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn wcsnset ( _String : * mut wchar_t , _Value : wchar_t , _MaxCount : usize ) -> * mut wchar_t ; } extern "C" { pub fn wcsrev ( _String : * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcsset ( _String : * mut wchar_t , _Value : wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcslwr ( _String : * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcsupr ( _String : * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcsicoll ( _String1 : * const wchar_t , _String2 : * const wchar_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strcpy_s ( _Destination : * mut :: std :: os :: raw :: c_char , _SizeInBytes : rsize_t , _Source : * const :: std :: os :: raw :: c_char ) -> errno_t ; } extern "C" { pub fn strcat_s ( _Destination : * mut :: std :: os :: raw :: c_char , _SizeInBytes : rsize_t , _Source : * const :: std :: os :: raw :: c_char ) -> errno_t ; } extern "C" { pub fn strerror_s ( _Buffer : * mut :: std :: os :: raw :: c_char , _SizeInBytes : usize , _ErrorNumber : :: std :: os :: raw :: c_int ) -> errno_t ; } extern "C" { pub fn strncat_s ( _Destination : * mut :: std :: os :: raw :: c_char , _SizeInBytes : rsize_t , _Source : * const :: std :: os :: raw :: c_char , _MaxCount : rsize_t ) -> errno_t ; } extern "C" { pub fn strncpy_s ( _Destination : * mut :: std :: os :: raw :: c_char , _SizeInBytes : rsize_t , _Source : * const :: std :: os :: raw :: c_char , _MaxCount : rsize_t ) -> errno_t ; } extern "C" { pub fn strtok_s ( _String : * mut :: std :: os :: raw :: c_char , _Delimiter : * const :: std :: os :: raw :: c_char , _Context : * mut * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _memccpy ( _Dst : * mut :: std :: os :: raw :: c_void , _Src : * const :: std :: os :: raw :: c_void , _Val : :: std :: os :: raw :: c_int , _MaxCount : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn strcat ( _Destination : * mut :: std :: os :: raw :: c_char , _Source : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcmp ( _Str1 : * const :: std :: os :: raw :: c_char , _Str2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _strcmpi ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strcoll ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _strcoll_l ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strcpy ( _Destination : * mut :: std :: os :: raw :: c_char , _Source : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcspn ( _Str : * const :: std :: os :: raw :: c_char , _Control : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { pub fn _strdup ( _Source : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _strerror ( _ErrorMessage : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _strerror_s ( _Buffer : * mut :: std :: os :: raw :: c_char , _SizeInBytes : usize , _ErrorMessage : * const :: std :: os :: raw :: c_char ) -> errno_t ; } extern "C" { pub fn strerror ( _ErrorMessage : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _stricmp ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _stricoll ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _stricoll_l ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _stricmp_l ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strlen ( _Str : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { pub fn _strlwr_s ( _String : * mut :: std :: os :: raw :: c_char , _Size : usize ) -> errno_t ; } extern "C" { pub fn _strlwr ( _String : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _strlwr_s_l ( _String : * mut :: std :: os :: raw :: c_char , _Size : usize , _Locale : _locale_t ) -> errno_t ; } extern "C" { pub fn _strlwr_l ( _String : * mut :: std :: os :: raw :: c_char , _Locale : _locale_t ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strncat ( _Destination : * mut :: std :: os :: raw :: c_char , _Source : * const :: std :: os :: raw :: c_char , _Count : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strncmp ( _Str1 : * const :: std :: os :: raw :: c_char , _Str2 : * const :: std :: os :: raw :: c_char , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _strnicmp ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _strnicmp_l ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _MaxCount : usize , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _strnicoll ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _strnicoll_l ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _MaxCount : usize , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _strncoll ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _strncoll_l ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _MaxCount : usize , _Locale : _locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __strncnt ( _String : * const :: std :: os :: raw :: c_char , _Count : usize ) -> usize ; } extern "C" { pub fn strncpy ( _Destination : * mut :: std :: os :: raw :: c_char , _Source : * const :: std :: os :: raw :: c_char , _Count : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strnlen ( _String : * const :: std :: os :: raw :: c_char , _MaxCount : usize ) -> usize ; } extern "C" { pub fn _strnset_s ( _String : * mut :: std :: os :: raw :: c_char , _SizeInBytes : usize , _Value : :: std :: os :: raw :: c_int , _MaxCount : usize ) -> errno_t ; } extern "C" { pub fn _strnset ( _Destination : * mut :: std :: os :: raw :: c_char , _Value : :: std :: os :: raw :: c_int , _Count : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strpbrk ( _Str : * const :: std :: os :: raw :: c_char , _Control : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _strrev ( _Str : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _strset_s ( _Destination : * mut :: std :: os :: raw :: c_char , _DestinationSize : usize , _Value : :: std :: os :: raw :: c_int ) -> errno_t ; } extern "C" { pub fn _strset ( _Destination : * mut :: std :: os :: raw :: c_char , _Value : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strspn ( _Str : * const :: std :: os :: raw :: c_char , _Control : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { pub fn strtok ( _String : * mut :: std :: os :: raw :: c_char , _Delimiter : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _strupr_s ( _String : * mut :: std :: os :: raw :: c_char , _Size : usize ) -> errno_t ; } extern "C" { pub fn _strupr ( _String : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _strupr_s_l ( _String : * mut :: std :: os :: raw :: c_char , _Size : usize , _Locale : _locale_t ) -> errno_t ; } extern "C" { pub fn _strupr_l ( _String : * mut :: std :: os :: raw :: c_char , _Locale : _locale_t ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strxfrm ( _Destination : * mut :: std :: os :: raw :: c_char , _Source : * const :: std :: os :: raw :: c_char , _MaxCount : usize ) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { pub fn _strxfrm_l ( _Destination : * mut :: std :: os :: raw :: c_char , _Source : * const :: std :: os :: raw :: c_char , _MaxCount : usize , _Locale : _locale_t ) -> usize ; } extern "C" { pub fn strdup ( _String : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcmpi ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn stricmp ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strlwr ( _String : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strnicmp ( _String1 : * const :: std :: os :: raw :: c_char , _String2 : * const :: std :: os :: raw :: c_char , _MaxCount : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strnset ( _String : * mut :: std :: os :: raw :: c_char , _Value : :: std :: os :: raw :: c_int , _MaxCount : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strrev ( _String : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strset ( _String : * mut :: std :: os :: raw :: c_char , _Value : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strupr ( _String : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HT_EventKlassInfoEvent { pub base : HT_Event , pub info_klass_id : HT_EventKlassId , pub event_klass_name : * const :: std :: os :: raw :: c_char , pub field_count : i8 , } # [ test ] fn bindgen_test_layout_HT_EventKlassInfoEvent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HT_EventKlassInfoEvent > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( HT_EventKlassInfoEvent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HT_EventKlassInfoEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( HT_EventKlassInfoEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassInfoEvent > ( ) ) ) . base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassInfoEvent ) , "::" , stringify ! ( base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassInfoEvent > ( ) ) ) . info_klass_id as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassInfoEvent ) , "::" , stringify ! ( info_klass_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassInfoEvent > ( ) ) ) . event_klass_name as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassInfoEvent ) , "::" , stringify ! ( event_klass_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassInfoEvent > ( ) ) ) . field_count as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassInfoEvent ) , "::" , stringify ! ( field_count ) ) ) ; } extern "C" { pub fn mkcreflect_get_HT_EventKlassInfoEvent_type_info ( ) -> * mut MKCREFLECT_TypeInfo ; } extern "C" { pub fn ht_HT_EventKlassInfoEvent_get_size ( VAR_NAME : * mut HT_Event ) -> usize ; } extern "C" { pub fn ht_HT_EventKlassInfoEvent_fnc_serialize ( VAR_NAME_ : * mut HT_Event , buffer : * mut HT_Byte ) -> usize ; } extern "C" { pub fn ht_HT_EventKlassInfoEvent_get_event_klass_instance ( ) -> * mut HT_EventKlass ; } extern "C" { pub fn ht_HT_EventKlassInfoEvent_register_event_klass ( ) -> HT_EventKlassId ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HT_EventKlassFieldInfoEvent { pub base : HT_Event , pub info_klass_id : HT_EventKlassId , pub field_type : * const :: std :: os :: raw :: c_char , pub field_name : * const :: std :: os :: raw :: c_char , pub size : u64 , pub data_type : u8 , } # [ test ] fn bindgen_test_layout_HT_EventKlassFieldInfoEvent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HT_EventKlassFieldInfoEvent > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( HT_EventKlassFieldInfoEvent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HT_EventKlassFieldInfoEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( HT_EventKlassFieldInfoEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassFieldInfoEvent > ( ) ) ) . base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassFieldInfoEvent ) , "::" , stringify ! ( base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassFieldInfoEvent > ( ) ) ) . info_klass_id as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassFieldInfoEvent ) , "::" , stringify ! ( info_klass_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassFieldInfoEvent > ( ) ) ) . field_type as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassFieldInfoEvent ) , "::" , stringify ! ( field_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassFieldInfoEvent > ( ) ) ) . field_name as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassFieldInfoEvent ) , "::" , stringify ! ( field_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassFieldInfoEvent > ( ) ) ) . size as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassFieldInfoEvent ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassFieldInfoEvent > ( ) ) ) . data_type as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassFieldInfoEvent ) , "::" , stringify ! ( data_type ) ) ) ; } extern "C" { pub fn mkcreflect_get_HT_EventKlassFieldInfoEvent_type_info ( ) -> * mut MKCREFLECT_TypeInfo ; } extern "C" { pub fn ht_HT_EventKlassFieldInfoEvent_get_size ( VAR_NAME : * mut HT_Event ) -> usize ; } extern "C" { pub fn ht_HT_EventKlassFieldInfoEvent_fnc_serialize ( VAR_NAME_ : * mut HT_Event , buffer : * mut HT_Byte ) -> usize ; } extern "C" { pub fn ht_HT_EventKlassFieldInfoEvent_get_event_klass_instance ( ) -> * mut HT_EventKlass ; } extern "C" { pub fn ht_HT_EventKlassFieldInfoEvent_register_event_klass ( ) -> HT_EventKlassId ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HT_CallstackBaseEvent { pub base : HT_Event , pub duration : HT_DurationNs , pub thread_id : HT_ThreadId , } # [ test ] fn bindgen_test_layout_HT_CallstackBaseEvent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HT_CallstackBaseEvent > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( HT_CallstackBaseEvent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HT_CallstackBaseEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( HT_CallstackBaseEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_CallstackBaseEvent > ( ) ) ) . base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HT_CallstackBaseEvent ) , "::" , stringify ! ( base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_CallstackBaseEvent > ( ) ) ) . duration as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( HT_CallstackBaseEvent ) , "::" , stringify ! ( duration ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_CallstackBaseEvent > ( ) ) ) . thread_id as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( HT_CallstackBaseEvent ) , "::" , stringify ! ( thread_id ) ) ) ; } extern "C" { pub fn mkcreflect_get_HT_CallstackBaseEvent_type_info ( ) -> * mut MKCREFLECT_TypeInfo ; } extern "C" { pub fn ht_HT_CallstackBaseEvent_get_size ( VAR_NAME : * mut HT_Event ) -> usize ; } extern "C" { pub fn ht_HT_CallstackBaseEvent_fnc_serialize ( VAR_NAME_ : * mut HT_Event , buffer : * mut HT_Byte ) -> usize ; } extern "C" { pub fn ht_HT_CallstackBaseEvent_get_event_klass_instance ( ) -> * mut HT_EventKlass ; } extern "C" { pub fn ht_HT_CallstackBaseEvent_register_event_klass ( ) -> HT_EventKlassId ; } pub type HT_CallstackEventLabel = u64 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HT_CallstackIntEvent { pub base : HT_CallstackBaseEvent , pub label : HT_CallstackEventLabel , } # [ test ] fn bindgen_test_layout_HT_CallstackIntEvent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HT_CallstackIntEvent > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( HT_CallstackIntEvent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HT_CallstackIntEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( HT_CallstackIntEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_CallstackIntEvent > ( ) ) ) . base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HT_CallstackIntEvent ) , "::" , stringify ! ( base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_CallstackIntEvent > ( ) ) ) . label as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( HT_CallstackIntEvent ) , "::" , stringify ! ( label ) ) ) ; } extern "C" { pub fn mkcreflect_get_HT_CallstackIntEvent_type_info ( ) -> * mut MKCREFLECT_TypeInfo ; } extern "C" { pub fn ht_HT_CallstackIntEvent_get_size ( VAR_NAME : * mut HT_Event ) -> usize ; } extern "C" { pub fn ht_HT_CallstackIntEvent_fnc_serialize ( VAR_NAME_ : * mut HT_Event , buffer : * mut HT_Byte ) -> usize ; } extern "C" { pub fn ht_HT_CallstackIntEvent_get_event_klass_instance ( ) -> * mut HT_EventKlass ; } extern "C" { pub fn ht_HT_CallstackIntEvent_register_event_klass ( ) -> HT_EventKlassId ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HT_CallstackStringEvent { pub base : HT_CallstackBaseEvent , pub label : * const :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_HT_CallstackStringEvent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HT_CallstackStringEvent > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( HT_CallstackStringEvent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HT_CallstackStringEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( HT_CallstackStringEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_CallstackStringEvent > ( ) ) ) . base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HT_CallstackStringEvent ) , "::" , stringify ! ( base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_CallstackStringEvent > ( ) ) ) . label as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( HT_CallstackStringEvent ) , "::" , stringify ! ( label ) ) ) ; } extern "C" { pub fn mkcreflect_get_HT_CallstackStringEvent_type_info ( ) -> * mut MKCREFLECT_TypeInfo ; } extern "C" { pub fn ht_HT_CallstackStringEvent_get_size ( VAR_NAME : * mut HT_Event ) -> usize ; } extern "C" { pub fn ht_HT_CallstackStringEvent_fnc_serialize ( VAR_NAME_ : * mut HT_Event , buffer : * mut HT_Byte ) -> usize ; } extern "C" { pub fn ht_HT_CallstackStringEvent_get_event_klass_instance ( ) -> * mut HT_EventKlass ; } extern "C" { pub fn ht_HT_CallstackStringEvent_register_event_klass ( ) -> HT_EventKlassId ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HT_StringMappingEvent { pub base : HT_Event , pub identifier : u64 , pub label : * const :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_HT_StringMappingEvent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HT_StringMappingEvent > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( HT_StringMappingEvent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HT_StringMappingEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( HT_StringMappingEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_StringMappingEvent > ( ) ) ) . base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HT_StringMappingEvent ) , "::" , stringify ! ( base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_StringMappingEvent > ( ) ) ) . identifier as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( HT_StringMappingEvent ) , "::" , stringify ! ( identifier ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_StringMappingEvent > ( ) ) ) . label as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( HT_StringMappingEvent ) , "::" , stringify ! ( label ) ) ) ; } extern "C" { pub fn mkcreflect_get_HT_StringMappingEvent_type_info ( ) -> * mut MKCREFLECT_TypeInfo ; } extern "C" { pub fn ht_HT_StringMappingEvent_get_size ( VAR_NAME : * mut HT_Event ) -> usize ; } extern "C" { pub fn ht_HT_StringMappingEvent_fnc_serialize ( VAR_NAME_ : * mut HT_Event , buffer : * mut HT_Byte ) -> usize ; } extern "C" { pub fn ht_HT_StringMappingEvent_get_event_klass_instance ( ) -> * mut HT_EventKlass ; } extern "C" { pub fn ht_HT_StringMappingEvent_register_event_klass ( ) -> HT_EventKlassId ; } extern "C" { pub fn ht_feature_cached_string_enable ( timeline : * mut HT_Timeline ) -> HT_ErrorCode ; } extern "C" { pub fn ht_feature_cached_string_disable ( timeline : * mut HT_Timeline ) ; } extern "C" { pub fn ht_feature_cached_string_add_mapping ( timeline : * mut HT_Timeline , label : * const :: std :: os :: raw :: c_char ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn ht_feature_cached_string_push_map ( timeline : * mut HT_Timeline ) ; } extern "C" { pub fn ht_feature_callstack_enable ( timeline : * mut HT_Timeline ) -> HT_ErrorCode ; } extern "C" { pub fn ht_feature_callstack_disable ( timeline : * mut HT_Timeline ) ; } extern "C" { pub fn ht_feature_callstack_start ( timeline : * mut HT_Timeline , event : * mut HT_CallstackBaseEvent ) ; } extern "C" { pub fn ht_feature_callstack_stop ( timeline : * mut HT_Timeline ) ; } extern "C" { pub fn ht_feature_callstack_start_int ( timeline : * mut HT_Timeline , label : HT_CallstackEventLabel ) ; } extern "C" { pub fn ht_feature_callstack_start_string ( timeline : * mut HT_Timeline , label : * const :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn ht_global_timeline_get ( ) -> * mut HT_Timeline ; } extern "C" { 
 /// Initializes HawkTracer library.
///
/// This function must be called before any other function
/// from this library. The only exception is ht_allocator_set(),
/// which must be called before ht_init().
///
/// @param argc a number of arguments of the @a argv array.
/// @param argv an array of strings - arguments for HawkTracer library. 
 pub fn ht_init ( argc : :: std :: os :: raw :: c_int , argv : * mut * mut :: std :: os :: raw :: c_char ) ; } extern "C" { 
 /// Uninitializes HawkTracer library.
///
/// This function must be called as a last function
/// of the library in the program. The only exception is
/// ht_timeline_deinit() which might be called after ht_deinit(),
/// however, it's highly not recommended and should be avoided
/// when possible. 
 pub fn ht_deinit ( ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _iobuf { pub _Placeholder : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout__iobuf ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _iobuf > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( _iobuf ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _iobuf > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _iobuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _iobuf > ( ) ) ) . _Placeholder as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _iobuf ) , "::" , stringify ! ( _Placeholder ) ) ) ; } pub type FILE = _iobuf ; extern "C" { pub fn __acrt_iob_func ( _Ix : :: std :: os :: raw :: c_uint ) -> * mut FILE ; } extern "C" { pub fn fgetwc ( _Stream : * mut FILE ) -> wint_t ; } extern "C" { pub fn _fgetwchar ( ) -> wint_t ; } extern "C" { pub fn fputwc ( _Character : wchar_t , _Stream : * mut FILE ) -> wint_t ; } extern "C" { pub fn _fputwchar ( _Character : wchar_t ) -> wint_t ; } extern "C" { pub fn getwc ( _Stream : * mut FILE ) -> wint_t ; } extern "C" { pub fn getwchar ( ) -> wint_t ; } extern "C" { pub fn fgetws ( _Buffer : * mut wchar_t , _BufferCount : :: std :: os :: raw :: c_int , _Stream : * mut FILE ) -> * mut wchar_t ; } extern "C" { pub fn fputws ( _Buffer : * const wchar_t , _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _getws_s ( _Buffer : * mut wchar_t , _BufferCount : usize ) -> * mut wchar_t ; } extern "C" { pub fn putwc ( _Character : wchar_t , _Stream : * mut FILE ) -> wint_t ; } extern "C" { pub fn putwchar ( _Character : wchar_t ) -> wint_t ; } extern "C" { pub fn _putws ( _Buffer : * const wchar_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ungetwc ( _Character : wint_t , _Stream : * mut FILE ) -> wint_t ; } extern "C" { pub fn _wfdopen ( _FileHandle : :: std :: os :: raw :: c_int , _Mode : * const wchar_t ) -> * mut FILE ; } extern "C" { pub fn _wfopen ( _FileName : * const wchar_t , _Mode : * const wchar_t ) -> * mut FILE ; } extern "C" { pub fn _wfopen_s ( _Stream : * mut * mut FILE , _FileName : * const wchar_t , _Mode : * const wchar_t ) -> errno_t ; } extern "C" { pub fn _wfreopen ( _FileName : * const wchar_t , _Mode : * const wchar_t , _OldStream : * mut FILE ) -> * mut FILE ; } extern "C" { pub fn _wfreopen_s ( _Stream : * mut * mut FILE , _FileName : * const wchar_t , _Mode : * const wchar_t , _OldStream : * mut FILE ) -> errno_t ; } extern "C" { pub fn _wfsopen ( _FileName : * const wchar_t , _Mode : * const wchar_t , _ShFlag : :: std :: os :: raw :: c_int ) -> * mut FILE ; } extern "C" { pub fn _wperror ( _ErrorMessage : * const wchar_t ) ; } extern "C" { pub fn _wpopen ( _Command : * const wchar_t , _Mode : * const wchar_t ) -> * mut FILE ; } extern "C" { pub fn _wremove ( _FileName : * const wchar_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _wtempnam ( _Directory : * const wchar_t , _FilePrefix : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn _wtmpnam_s ( _Buffer : * mut wchar_t , _BufferCount : usize ) -> errno_t ; } extern "C" { pub fn _wtmpnam ( _Buffer : * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn _fgetwc_nolock ( _Stream : * mut FILE ) -> wint_t ; } extern "C" { pub fn _fputwc_nolock ( _Character : wchar_t , _Stream : * mut FILE ) -> wint_t ; } extern "C" { pub fn _getwc_nolock ( _Stream : * mut FILE ) -> wint_t ; } extern "C" { pub fn _putwc_nolock ( _Character : wchar_t , _Stream : * mut FILE ) -> wint_t ; } extern "C" { pub fn _ungetwc_nolock ( _Character : wint_t , _Stream : * mut FILE ) -> wint_t ; } extern "C" { pub fn __stdio_common_vfwprintf ( _Options : :: std :: os :: raw :: c_ulonglong , _Stream : * mut FILE , _Format : * const wchar_t , _Locale : _locale_t , _ArgList : va_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __stdio_common_vfwprintf_s ( _Options : :: std :: os :: raw :: c_ulonglong , _Stream : * mut FILE , _Format : * const wchar_t , _Locale : _locale_t , _ArgList : va_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __stdio_common_vfwprintf_p ( _Options : :: std :: os :: raw :: c_ulonglong , _Stream : * mut FILE , _Format : * const wchar_t , _Locale : _locale_t , _ArgList : va_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __stdio_common_vfwscanf ( _Options : :: std :: os :: raw :: c_ulonglong , _Stream : * mut FILE , _Format : * const wchar_t , _Locale : _locale_t , _ArgList : va_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __stdio_common_vswprintf ( _Options : :: std :: os :: raw :: c_ulonglong , _Buffer : * mut wchar_t , _BufferCount : usize , _Format : * const wchar_t , _Locale : _locale_t , _ArgList : va_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __stdio_common_vswprintf_s ( _Options : :: std :: os :: raw :: c_ulonglong , _Buffer : * mut wchar_t , _BufferCount : usize , _Format : * const wchar_t , _Locale : _locale_t , _ArgList : va_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __stdio_common_vsnwprintf_s ( _Options : :: std :: os :: raw :: c_ulonglong , _Buffer : * mut wchar_t , _BufferCount : usize , _MaxCount : usize , _Format : * const wchar_t , _Locale : _locale_t , _ArgList : va_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __stdio_common_vswprintf_p ( _Options : :: std :: os :: raw :: c_ulonglong , _Buffer : * mut wchar_t , _BufferCount : usize , _Format : * const wchar_t , _Locale : _locale_t , _ArgList : va_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __stdio_common_vswscanf ( _Options : :: std :: os :: raw :: c_ulonglong , _Buffer : * const wchar_t , _BufferCount : usize , _Format : * const wchar_t , _Locale : _locale_t , _ArgList : va_list ) -> :: std :: os :: raw :: c_int ; } pub type fpos_t = :: std :: os :: raw :: c_longlong ; extern "C" { pub fn _get_stream_buffer_pointers ( _Stream : * mut FILE , _Base : * mut * mut * mut :: std :: os :: raw :: c_char , _Pointer : * mut * mut * mut :: std :: os :: raw :: c_char , _Count : * mut * mut :: std :: os :: raw :: c_int ) -> errno_t ; } extern "C" { pub fn clearerr_s ( _Stream : * mut FILE ) -> errno_t ; } extern "C" { pub fn fopen_s ( _Stream : * mut * mut FILE , _FileName : * const :: std :: os :: raw :: c_char , _Mode : * const :: std :: os :: raw :: c_char ) -> errno_t ; } extern "C" { pub fn fread_s ( _Buffer : * mut :: std :: os :: raw :: c_void , _BufferSize : usize , _ElementSize : usize , _ElementCount : usize , _Stream : * mut FILE ) -> usize ; } extern "C" { pub fn freopen_s ( _Stream : * mut * mut FILE , _FileName : * const :: std :: os :: raw :: c_char , _Mode : * const :: std :: os :: raw :: c_char , _OldStream : * mut FILE ) -> errno_t ; } extern "C" { pub fn gets_s ( _Buffer : * mut :: std :: os :: raw :: c_char , _Size : rsize_t ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn tmpfile_s ( _Stream : * mut * mut FILE ) -> errno_t ; } extern "C" { pub fn tmpnam_s ( _Buffer : * mut :: std :: os :: raw :: c_char , _Size : rsize_t ) -> errno_t ; } extern "C" { pub fn clearerr ( _Stream : * mut FILE ) ; } extern "C" { pub fn fclose ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _fcloseall ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _fdopen ( _FileHandle : :: std :: os :: raw :: c_int , _Mode : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn feof ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ferror ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fflush ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgetc ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _fgetchar ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgetpos ( _Stream : * mut FILE , _Position : * mut fpos_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgets ( _Buffer : * mut :: std :: os :: raw :: c_char , _MaxCount : :: std :: os :: raw :: c_int , _Stream : * mut FILE ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn _fileno ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _flushall ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fopen ( _FileName : * const :: std :: os :: raw :: c_char , _Mode : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn fputc ( _Character : :: std :: os :: raw :: c_int , _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _fputchar ( _Character : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fputs ( _Buffer : * const :: std :: os :: raw :: c_char , _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fread ( _Buffer : * mut :: std :: os :: raw :: c_void , _ElementSize : usize , _ElementCount : usize , _Stream : * mut FILE ) -> usize ; } extern "C" { pub fn freopen ( _FileName : * const :: std :: os :: raw :: c_char , _Mode : * const :: std :: os :: raw :: c_char , _Stream : * mut FILE ) -> * mut FILE ; } extern "C" { pub fn _fsopen ( _FileName : * const :: std :: os :: raw :: c_char , _Mode : * const :: std :: os :: raw :: c_char , _ShFlag : :: std :: os :: raw :: c_int ) -> * mut FILE ; } extern "C" { pub fn fsetpos ( _Stream : * mut FILE , _Position : * const fpos_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fseek ( _Stream : * mut FILE , _Offset : :: std :: os :: raw :: c_long , _Origin : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _fseeki64 ( _Stream : * mut FILE , _Offset : :: std :: os :: raw :: c_longlong , _Origin : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ftell ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn _ftelli64 ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_longlong ; } extern "C" { pub fn fwrite ( _Buffer : * const :: std :: os :: raw :: c_void , _ElementSize : usize , _ElementCount : usize , _Stream : * mut FILE ) -> usize ; } extern "C" { pub fn getc ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getchar ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _getmaxstdio ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _getw ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn perror ( _ErrorMessage : * const :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn _pclose ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _popen ( _Command : * const :: std :: os :: raw :: c_char , _Mode : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn putc ( _Character : :: std :: os :: raw :: c_int , _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putchar ( _Character : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn puts ( _Buffer : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _putw ( _Word : :: std :: os :: raw :: c_int , _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn remove ( _FileName : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn rename ( _OldFileName : * const :: std :: os :: raw :: c_char , _NewFileName : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _unlink ( _FileName : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn unlink ( _FileName : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn rewind ( _Stream : * mut FILE ) ; } extern "C" { pub fn _rmtmp ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setbuf ( _Stream : * mut FILE , _Buffer : * mut :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn _setmaxstdio ( _Maximum : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setvbuf ( _Stream : * mut FILE , _Buffer : * mut :: std :: os :: raw :: c_char , _Mode : :: std :: os :: raw :: c_int , _Size : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _tempnam ( _DirectoryName : * const :: std :: os :: raw :: c_char , _FilePrefix : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn tmpfile ( ) -> * mut FILE ; } extern "C" { pub fn tmpnam ( _Buffer : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn ungetc ( _Character : :: std :: os :: raw :: c_int , _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _lock_file ( _Stream : * mut FILE ) ; } extern "C" { pub fn _unlock_file ( _Stream : * mut FILE ) ; } extern "C" { pub fn _fclose_nolock ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _fflush_nolock ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _fgetc_nolock ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _fputc_nolock ( _Character : :: std :: os :: raw :: c_int , _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _fread_nolock ( _Buffer : * mut :: std :: os :: raw :: c_void , _ElementSize : usize , _ElementCount : usize , _Stream : * mut FILE ) -> usize ; } extern "C" { pub fn _fread_nolock_s ( _Buffer : * mut :: std :: os :: raw :: c_void , _BufferSize : usize , _ElementSize : usize , _ElementCount : usize , _Stream : * mut FILE ) -> usize ; } extern "C" { pub fn _fseek_nolock ( _Stream : * mut FILE , _Offset : :: std :: os :: raw :: c_long , _Origin : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _fseeki64_nolock ( _Stream : * mut FILE , _Offset : :: std :: os :: raw :: c_longlong , _Origin : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _ftell_nolock ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn _ftelli64_nolock ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_longlong ; } extern "C" { pub fn _fwrite_nolock ( _Buffer : * const :: std :: os :: raw :: c_void , _ElementSize : usize , _ElementCount : usize , _Stream : * mut FILE ) -> usize ; } extern "C" { pub fn _getc_nolock ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _putc_nolock ( _Character : :: std :: os :: raw :: c_int , _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _ungetc_nolock ( _Character : :: std :: os :: raw :: c_int , _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __p__commode ( ) -> * mut :: std :: os :: raw :: c_int ; } extern "C" { pub fn __stdio_common_vfprintf ( _Options : :: std :: os :: raw :: c_ulonglong , _Stream : * mut FILE , _Format : * const :: std :: os :: raw :: c_char , _Locale : _locale_t , _ArgList : va_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __stdio_common_vfprintf_s ( _Options : :: std :: os :: raw :: c_ulonglong , _Stream : * mut FILE , _Format : * const :: std :: os :: raw :: c_char , _Locale : _locale_t , _ArgList : va_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __stdio_common_vfprintf_p ( _Options : :: std :: os :: raw :: c_ulonglong , _Stream : * mut FILE , _Format : * const :: std :: os :: raw :: c_char , _Locale : _locale_t , _ArgList : va_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _set_printf_count_output ( _Value : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _get_printf_count_output ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __stdio_common_vfscanf ( _Options : :: std :: os :: raw :: c_ulonglong , _Stream : * mut FILE , _Format : * const :: std :: os :: raw :: c_char , _Locale : _locale_t , _Arglist : va_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __stdio_common_vsprintf ( _Options : :: std :: os :: raw :: c_ulonglong , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Format : * const :: std :: os :: raw :: c_char , _Locale : _locale_t , _ArgList : va_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __stdio_common_vsprintf_s ( _Options : :: std :: os :: raw :: c_ulonglong , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Format : * const :: std :: os :: raw :: c_char , _Locale : _locale_t , _ArgList : va_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __stdio_common_vsnprintf_s ( _Options : :: std :: os :: raw :: c_ulonglong , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _MaxCount : usize , _Format : * const :: std :: os :: raw :: c_char , _Locale : _locale_t , _ArgList : va_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __stdio_common_vsprintf_p ( _Options : :: std :: os :: raw :: c_ulonglong , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Format : * const :: std :: os :: raw :: c_char , _Locale : _locale_t , _ArgList : va_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __stdio_common_vsscanf ( _Options : :: std :: os :: raw :: c_ulonglong , _Buffer : * const :: std :: os :: raw :: c_char , _BufferCount : usize , _Format : * const :: std :: os :: raw :: c_char , _Locale : _locale_t , _ArgList : va_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn tempnam ( _Directory : * const :: std :: os :: raw :: c_char , _FilePrefix : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn fcloseall ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fdopen ( _FileHandle : :: std :: os :: raw :: c_int , _Format : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn fgetchar ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fileno ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn flushall ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fputchar ( _Ch : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getw ( _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putw ( _Ch : :: std :: os :: raw :: c_int , _Stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn rmtmp ( ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _HT_FileDumpListener { _unused : [ u8 ; 0 ] , } pub type HT_FileDumpListener = _HT_FileDumpListener ; extern "C" { pub fn ht_file_dump_listener_create ( filename : * const :: std :: os :: raw :: c_char , buffer_size : usize , out_err : * mut HT_ErrorCode ) -> * mut HT_FileDumpListener ; } extern "C" { pub fn ht_file_dump_listener_destroy ( listener : * mut HT_FileDumpListener ) ; } extern "C" { pub fn ht_file_dump_listener_callback ( events : TEventPtr , size : usize , serialized : HT_Boolean , user_data : * mut :: std :: os :: raw :: c_void ) ; } 
 /// A task scheduler's callback. 
 pub type HT_TaskCallback = :: std :: option :: Option < unsafe extern "C" fn ( user_data : * mut :: std :: os :: raw :: c_void ) > ; 
 /// A task scheduler's task identifier. 
 pub type HT_TaskId = i32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _HT_Task { _unused : [ u8 ; 0 ] , } pub type HT_Task = _HT_Task ; 
 /// Ignores task execution delays; if the task has been run after the timeout,
/// next task execution will be performed according to a schedule
/// (so it won't be affected by a previous delay). 
 pub const HT_TaskSchedulingMode_HT_TASK_SCHEDULING_IGNORE_DELAYS : HT_TaskSchedulingMode = 0 ; 
 /// Takes delays into account, and restarts the timer for the task after its execution;
/// if task was delayed, next task will be executed after a @b period time of the previous
/// execution. 
 pub const HT_TaskSchedulingMode_HT_TASK_SCHEDULING_RESTART_TIMER : HT_TaskSchedulingMode = 1 ; 
 /// Task scheduling mode. 
 pub type HT_TaskSchedulingMode = i32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _HT_TaskScheduler { _unused : [ u8 ; 0 ] , } pub type HT_TaskScheduler = _HT_TaskScheduler ; extern "C" { 
 /// Creates an instance of the HT_TaskScheduler structure.
///
/// @param out_err #HT_ERR_OK, if creation completed succesfully; otherwise, appropriate error code.
///
/// @return task_scheduler a pointer to the scheduler, or NULL if create failed. 
 pub fn ht_task_scheduler_create ( out_err : * mut HT_ErrorCode ) -> * mut HT_TaskScheduler ; } extern "C" { 
 /// Destroys task scheduler data structure.
///
/// @param task_scheduler a pointer to the scheduler. 
 pub fn ht_task_scheduler_destroy ( task_scheduler : * mut HT_TaskScheduler ) ; } extern "C" { 
 /// Adds a new task to a scheduler.
/// @param task_scheduler a pointer to the scheduler.
/// @param mode a task scheduling mode. @sa HT_TaskSchedulingMode
/// @param period a minimum time (in nanoseconds) between two executions of the task.
/// @param callback a task's function. Can not be NULL.
/// @param user_data a pointer to a data which is passed to a callback when executed.
///
/// @return a unique identifier of the task if the task is scheduled successfully; otherwise
/// #HT_TASK_SCHEDULER_INVALID_TASK_ID. 
 pub fn ht_task_scheduler_schedule_task ( task_scheduler : * mut HT_TaskScheduler , mode : HT_TaskSchedulingMode , period : HT_DurationNs , callback : HT_TaskCallback , user_data : * mut :: std :: os :: raw :: c_void ) -> HT_TaskId ; } extern "C" { 
 /// Deletes a task from a scheduler.
///
/// @param task_scheduler a pointer to the scheduler.
/// @param task_id an identifier of the task to remove.
///
/// @return #HT_TRUE, if task was removed successfully; if task doesn't exist, returns #HT_FALSE. 
 pub fn ht_task_scheduler_remove_task ( task_scheduler : * mut HT_TaskScheduler , task_id : HT_TaskId ) -> HT_Boolean ; } extern "C" { 
 /// Executes scheduled tasks when they time out.
///
/// @param task_scheduler a pointer to the scheduler. 
 pub fn ht_task_scheduler_tick ( task_scheduler : * mut HT_TaskScheduler ) ; } extern "C" { 
 /// Gets optimal tick period for scheduled tasks.
/// The function returns the greatest common divisor of all task periods.
/// E.g. for following periods of scheduled tasks: (10, 15, 25), optimal tick period is 5.
///
/// @note This function ignores tasks with period equal to 0. Therefore optimal tick period
/// for task periods: (10, 15, 25, 0) is still 5.
///
/// @param task_scheduler a pointer to the scheduler.
///
/// @return optimal tick period. 
 pub fn ht_task_scheduler_get_optimal_tick_period ( task_scheduler : * mut HT_TaskScheduler ) -> HT_DurationNs ; } extern "C" { 
 /// Gets a unique identifier of the current thread.
///
/// @return an identifier of the current thread. 
 pub fn ht_thread_get_current_thread_id ( ) -> HT_ThreadId ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __crt_locale_data { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __crt_multibyte_data { pub _address : u8 , }