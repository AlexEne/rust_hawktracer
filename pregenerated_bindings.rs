/* automatically generated by rust-bindgen */

pub const HT_VERSION : & 'static [ u8 ; 6usize ] = b"0.6.0\0" ; pub const HT_VERSION_MAJOR : u32 = 0 ; pub const HT_VERSION_MINOR : u32 = 6 ; pub const HT_VERSION_PATCH : u32 = 0 ; pub const _INTTYPES_H : u32 = 1 ; pub const _FEATURES_H : u32 = 1 ; pub const _DEFAULT_SOURCE : u32 = 1 ; pub const __USE_ISOC11 : u32 = 1 ; pub const __USE_ISOC99 : u32 = 1 ; pub const __USE_ISOC95 : u32 = 1 ; pub const __USE_POSIX_IMPLICITLY : u32 = 1 ; pub const _POSIX_SOURCE : u32 = 1 ; pub const _POSIX_C_SOURCE : u32 = 200809 ; pub const __USE_POSIX : u32 = 1 ; pub const __USE_POSIX2 : u32 = 1 ; pub const __USE_POSIX199309 : u32 = 1 ; pub const __USE_POSIX199506 : u32 = 1 ; pub const __USE_XOPEN2K : u32 = 1 ; pub const __USE_XOPEN2K8 : u32 = 1 ; pub const _ATFILE_SOURCE : u32 = 1 ; pub const __USE_MISC : u32 = 1 ; pub const __USE_ATFILE : u32 = 1 ; pub const __USE_FORTIFY_LEVEL : u32 = 0 ; pub const __GLIBC_USE_DEPRECATED_GETS : u32 = 0 ; pub const _STDC_PREDEF_H : u32 = 1 ; pub const __STDC_IEC_559__ : u32 = 1 ; pub const __STDC_IEC_559_COMPLEX__ : u32 = 1 ; pub const __STDC_ISO_10646__ : u32 = 201706 ; pub const __STDC_NO_THREADS__ : u32 = 1 ; pub const __GNU_LIBRARY__ : u32 = 6 ; pub const __GLIBC__ : u32 = 2 ; pub const __GLIBC_MINOR__ : u32 = 27 ; pub const _SYS_CDEFS_H : u32 = 1 ; pub const __glibc_c99_flexarr_available : u32 = 1 ; pub const __WORDSIZE : u32 = 64 ; pub const __WORDSIZE_TIME64_COMPAT32 : u32 = 1 ; pub const __SYSCALL_WORDSIZE : u32 = 64 ; pub const __HAVE_GENERIC_SELECTION : u32 = 1 ; pub const _STDINT_H : u32 = 1 ; pub const __GLIBC_USE_LIB_EXT2 : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_BFP_EXT : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_FUNCS_EXT : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_TYPES_EXT : u32 = 0 ; pub const _BITS_TYPES_H : u32 = 1 ; pub const _BITS_TYPESIZES_H : u32 = 1 ; pub const __OFF_T_MATCHES_OFF64_T : u32 = 1 ; pub const __INO_T_MATCHES_INO64_T : u32 = 1 ; pub const __RLIM_T_MATCHES_RLIM64_T : u32 = 1 ; pub const __FD_SETSIZE : u32 = 1024 ; pub const _BITS_WCHAR_H : u32 = 1 ; pub const _BITS_STDINT_INTN_H : u32 = 1 ; pub const _BITS_STDINT_UINTN_H : u32 = 1 ; pub const INT8_MIN : i32 = -128 ; pub const INT16_MIN : i32 = -32768 ; pub const INT32_MIN : i32 = -2147483648 ; pub const INT8_MAX : u32 = 127 ; pub const INT16_MAX : u32 = 32767 ; pub const INT32_MAX : u32 = 2147483647 ; pub const UINT8_MAX : u32 = 255 ; pub const UINT16_MAX : u32 = 65535 ; pub const UINT32_MAX : u32 = 4294967295 ; pub const INT_LEAST8_MIN : i32 = -128 ; pub const INT_LEAST16_MIN : i32 = -32768 ; pub const INT_LEAST32_MIN : i32 = -2147483648 ; pub const INT_LEAST8_MAX : u32 = 127 ; pub const INT_LEAST16_MAX : u32 = 32767 ; pub const INT_LEAST32_MAX : u32 = 2147483647 ; pub const UINT_LEAST8_MAX : u32 = 255 ; pub const UINT_LEAST16_MAX : u32 = 65535 ; pub const UINT_LEAST32_MAX : u32 = 4294967295 ; pub const INT_FAST8_MIN : i32 = -128 ; pub const INT_FAST16_MIN : i64 = -9223372036854775808 ; pub const INT_FAST32_MIN : i64 = -9223372036854775808 ; pub const INT_FAST8_MAX : u32 = 127 ; pub const INT_FAST16_MAX : u64 = 9223372036854775807 ; pub const INT_FAST32_MAX : u64 = 9223372036854775807 ; pub const UINT_FAST8_MAX : u32 = 255 ; pub const UINT_FAST16_MAX : i32 = -1 ; pub const UINT_FAST32_MAX : i32 = -1 ; pub const INTPTR_MIN : i64 = -9223372036854775808 ; pub const INTPTR_MAX : u64 = 9223372036854775807 ; pub const UINTPTR_MAX : i32 = -1 ; pub const PTRDIFF_MIN : i64 = -9223372036854775808 ; pub const PTRDIFF_MAX : u64 = 9223372036854775807 ; pub const SIG_ATOMIC_MIN : i32 = -2147483648 ; pub const SIG_ATOMIC_MAX : u32 = 2147483647 ; pub const SIZE_MAX : i32 = -1 ; pub const WINT_MIN : u32 = 0 ; pub const WINT_MAX : u32 = 4294967295 ; pub const ____gwchar_t_defined : u32 = 1 ; pub const __PRI64_PREFIX : & 'static [ u8 ; 2usize ] = b"l\0" ; pub const __PRIPTR_PREFIX : & 'static [ u8 ; 2usize ] = b"l\0" ; pub const PRId8 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRId16 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRId32 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRId64 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const PRIdLEAST8 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRIdLEAST16 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRIdLEAST32 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRIdLEAST64 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const PRIdFAST8 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRIdFAST16 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const PRIdFAST32 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const PRIdFAST64 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const PRIi8 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIi16 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIi32 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIi64 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const PRIiLEAST8 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIiLEAST16 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIiLEAST32 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIiLEAST64 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const PRIiFAST8 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIiFAST16 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const PRIiFAST32 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const PRIiFAST64 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const PRIo8 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIo16 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIo32 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIo64 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const PRIoLEAST8 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIoLEAST16 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIoLEAST32 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIoLEAST64 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const PRIoFAST8 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIoFAST16 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const PRIoFAST32 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const PRIoFAST64 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const PRIu8 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIu16 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIu32 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIu64 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const PRIuLEAST8 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIuLEAST16 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIuLEAST32 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIuLEAST64 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const PRIuFAST8 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIuFAST16 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const PRIuFAST32 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const PRIuFAST64 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const PRIx8 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIx16 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIx32 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIx64 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const PRIxLEAST8 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIxLEAST16 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIxLEAST32 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIxLEAST64 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const PRIxFAST8 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIxFAST16 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const PRIxFAST32 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const PRIxFAST64 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const PRIX8 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIX16 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIX32 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIX64 : & 'static [ u8 ; 3usize ] = b"lX\0" ; pub const PRIXLEAST8 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIXLEAST16 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIXLEAST32 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIXLEAST64 : & 'static [ u8 ; 3usize ] = b"lX\0" ; pub const PRIXFAST8 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIXFAST16 : & 'static [ u8 ; 3usize ] = b"lX\0" ; pub const PRIXFAST32 : & 'static [ u8 ; 3usize ] = b"lX\0" ; pub const PRIXFAST64 : & 'static [ u8 ; 3usize ] = b"lX\0" ; pub const PRIdMAX : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const PRIiMAX : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const PRIoMAX : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const PRIuMAX : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const PRIxMAX : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const PRIXMAX : & 'static [ u8 ; 3usize ] = b"lX\0" ; pub const PRIdPTR : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const PRIiPTR : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const PRIoPTR : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const PRIuPTR : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const PRIxPTR : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const PRIXPTR : & 'static [ u8 ; 3usize ] = b"lX\0" ; pub const SCNd8 : & 'static [ u8 ; 4usize ] = b"hhd\0" ; pub const SCNd16 : & 'static [ u8 ; 3usize ] = b"hd\0" ; pub const SCNd32 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const SCNd64 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const SCNdLEAST8 : & 'static [ u8 ; 4usize ] = b"hhd\0" ; pub const SCNdLEAST16 : & 'static [ u8 ; 3usize ] = b"hd\0" ; pub const SCNdLEAST32 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const SCNdLEAST64 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const SCNdFAST8 : & 'static [ u8 ; 4usize ] = b"hhd\0" ; pub const SCNdFAST16 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const SCNdFAST32 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const SCNdFAST64 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const SCNi8 : & 'static [ u8 ; 4usize ] = b"hhi\0" ; pub const SCNi16 : & 'static [ u8 ; 3usize ] = b"hi\0" ; pub const SCNi32 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const SCNi64 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const SCNiLEAST8 : & 'static [ u8 ; 4usize ] = b"hhi\0" ; pub const SCNiLEAST16 : & 'static [ u8 ; 3usize ] = b"hi\0" ; pub const SCNiLEAST32 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const SCNiLEAST64 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const SCNiFAST8 : & 'static [ u8 ; 4usize ] = b"hhi\0" ; pub const SCNiFAST16 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const SCNiFAST32 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const SCNiFAST64 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const SCNu8 : & 'static [ u8 ; 4usize ] = b"hhu\0" ; pub const SCNu16 : & 'static [ u8 ; 3usize ] = b"hu\0" ; pub const SCNu32 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const SCNu64 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const SCNuLEAST8 : & 'static [ u8 ; 4usize ] = b"hhu\0" ; pub const SCNuLEAST16 : & 'static [ u8 ; 3usize ] = b"hu\0" ; pub const SCNuLEAST32 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const SCNuLEAST64 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const SCNuFAST8 : & 'static [ u8 ; 4usize ] = b"hhu\0" ; pub const SCNuFAST16 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const SCNuFAST32 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const SCNuFAST64 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const SCNo8 : & 'static [ u8 ; 4usize ] = b"hho\0" ; pub const SCNo16 : & 'static [ u8 ; 3usize ] = b"ho\0" ; pub const SCNo32 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const SCNo64 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const SCNoLEAST8 : & 'static [ u8 ; 4usize ] = b"hho\0" ; pub const SCNoLEAST16 : & 'static [ u8 ; 3usize ] = b"ho\0" ; pub const SCNoLEAST32 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const SCNoLEAST64 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const SCNoFAST8 : & 'static [ u8 ; 4usize ] = b"hho\0" ; pub const SCNoFAST16 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const SCNoFAST32 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const SCNoFAST64 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const SCNx8 : & 'static [ u8 ; 4usize ] = b"hhx\0" ; pub const SCNx16 : & 'static [ u8 ; 3usize ] = b"hx\0" ; pub const SCNx32 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const SCNx64 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const SCNxLEAST8 : & 'static [ u8 ; 4usize ] = b"hhx\0" ; pub const SCNxLEAST16 : & 'static [ u8 ; 3usize ] = b"hx\0" ; pub const SCNxLEAST32 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const SCNxLEAST64 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const SCNxFAST8 : & 'static [ u8 ; 4usize ] = b"hhx\0" ; pub const SCNxFAST16 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const SCNxFAST32 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const SCNxFAST64 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const SCNdMAX : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const SCNiMAX : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const SCNoMAX : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const SCNuMAX : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const SCNxMAX : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const SCNdPTR : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const SCNiPTR : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const SCNoPTR : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const SCNuPTR : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const SCNxPTR : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const HT_TRUE : u32 = 1 ; pub const HT_FALSE : u32 = 0 ; pub const HT_TIMELINE_MAX_FEATURES : u32 = 32 ; pub const _STRING_H : u32 = 1 ; pub const _BITS_TYPES_LOCALE_T_H : u32 = 1 ; pub const _BITS_TYPES___LOCALE_T_H : u32 = 1 ; pub const _STRINGS_H : u32 = 1 ; pub const HT_FEATURE_CACHED_STRING : u32 = 1 ; pub const HT_FEATURE_CALLSTACK : u32 = 0 ; pub const _PTHREAD_H : u32 = 1 ; pub const _ENDIAN_H : u32 = 1 ; pub const __LITTLE_ENDIAN : u32 = 1234 ; pub const __BIG_ENDIAN : u32 = 4321 ; pub const __PDP_ENDIAN : u32 = 3412 ; pub const __BYTE_ORDER : u32 = 1234 ; pub const __FLOAT_WORD_ORDER : u32 = 1234 ; pub const LITTLE_ENDIAN : u32 = 1234 ; pub const BIG_ENDIAN : u32 = 4321 ; pub const PDP_ENDIAN : u32 = 3412 ; pub const BYTE_ORDER : u32 = 1234 ; pub const _BITS_BYTESWAP_H : u32 = 1 ; pub const _BITS_UINTN_IDENTITY_H : u32 = 1 ; pub const _SCHED_H : u32 = 1 ; pub const __time_t_defined : u32 = 1 ; pub const _STRUCT_TIMESPEC : u32 = 1 ; pub const _BITS_SCHED_H : u32 = 1 ; pub const SCHED_OTHER : u32 = 0 ; pub const SCHED_FIFO : u32 = 1 ; pub const SCHED_RR : u32 = 2 ; pub const _BITS_CPU_SET_H : u32 = 1 ; pub const __CPU_SETSIZE : u32 = 1024 ; pub const _TIME_H : u32 = 1 ; pub const _BITS_TIME_H : u32 = 1 ; pub const CLOCK_REALTIME : u32 = 0 ; pub const CLOCK_MONOTONIC : u32 = 1 ; pub const CLOCK_PROCESS_CPUTIME_ID : u32 = 2 ; pub const CLOCK_THREAD_CPUTIME_ID : u32 = 3 ; pub const CLOCK_MONOTONIC_RAW : u32 = 4 ; pub const CLOCK_REALTIME_COARSE : u32 = 5 ; pub const CLOCK_MONOTONIC_COARSE : u32 = 6 ; pub const CLOCK_BOOTTIME : u32 = 7 ; pub const CLOCK_REALTIME_ALARM : u32 = 8 ; pub const CLOCK_BOOTTIME_ALARM : u32 = 9 ; pub const CLOCK_TAI : u32 = 11 ; pub const TIMER_ABSTIME : u32 = 1 ; pub const __clock_t_defined : u32 = 1 ; pub const __struct_tm_defined : u32 = 1 ; pub const __clockid_t_defined : u32 = 1 ; pub const __timer_t_defined : u32 = 1 ; pub const __itimerspec_defined : u32 = 1 ; pub const TIME_UTC : u32 = 1 ; pub const _BITS_PTHREADTYPES_COMMON_H : u32 = 1 ; pub const _THREAD_SHARED_TYPES_H : u32 = 1 ; pub const _BITS_PTHREADTYPES_ARCH_H : u32 = 1 ; pub const __SIZEOF_PTHREAD_MUTEX_T : u32 = 40 ; pub const __SIZEOF_PTHREAD_ATTR_T : u32 = 56 ; pub const __SIZEOF_PTHREAD_RWLOCK_T : u32 = 56 ; pub const __SIZEOF_PTHREAD_BARRIER_T : u32 = 32 ; pub const __SIZEOF_PTHREAD_MUTEXATTR_T : u32 = 4 ; pub const __SIZEOF_PTHREAD_COND_T : u32 = 48 ; pub const __SIZEOF_PTHREAD_CONDATTR_T : u32 = 4 ; pub const __SIZEOF_PTHREAD_RWLOCKATTR_T : u32 = 8 ; pub const __SIZEOF_PTHREAD_BARRIERATTR_T : u32 = 4 ; pub const __PTHREAD_MUTEX_LOCK_ELISION : u32 = 1 ; pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND : u32 = 0 ; pub const __PTHREAD_MUTEX_USE_UNION : u32 = 0 ; pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED : u32 = 1 ; pub const __PTHREAD_MUTEX_HAVE_PREV : u32 = 1 ; pub const __have_pthread_attr_t : u32 = 1 ; pub const _BITS_SETJMP_H : u32 = 1 ; pub const PTHREAD_ONCE_INIT : u32 = 0 ; pub const PTHREAD_BARRIER_SERIAL_THREAD : i32 = -1 ; pub const _STDIO_H : u32 = 1 ; pub const ____FILE_defined : u32 = 1 ; pub const __FILE_defined : u32 = 1 ; pub const _BITS_LIBIO_H : u32 = 1 ; pub const _BITS_G_CONFIG_H : u32 = 1 ; pub const ____mbstate_t_defined : u32 = 1 ; pub const _G_HAVE_MMAP : u32 = 1 ; pub const _G_HAVE_MREMAP : u32 = 1 ; pub const _G_IO_IO_FILE_VERSION : u32 = 131073 ; pub const _G_BUFSIZ : u32 = 8192 ; pub const _IO_BUFSIZ : u32 = 8192 ; pub const __GNUC_VA_LIST : u32 = 1 ; pub const _IO_UNIFIED_JUMPTABLES : u32 = 1 ; pub const EOF : i32 = -1 ; pub const _IOS_INPUT : u32 = 1 ; pub const _IOS_OUTPUT : u32 = 2 ; pub const _IOS_ATEND : u32 = 4 ; pub const _IOS_APPEND : u32 = 8 ; pub const _IOS_TRUNC : u32 = 16 ; pub const _IOS_NOCREATE : u32 = 32 ; pub const _IOS_NOREPLACE : u32 = 64 ; pub const _IOS_BIN : u32 = 128 ; pub const _IO_MAGIC : u32 = 4222418944 ; pub const _OLD_STDIO_MAGIC : u32 = 4206624768 ; pub const _IO_MAGIC_MASK : u32 = 4294901760 ; pub const _IO_USER_BUF : u32 = 1 ; pub const _IO_UNBUFFERED : u32 = 2 ; pub const _IO_NO_READS : u32 = 4 ; pub const _IO_NO_WRITES : u32 = 8 ; pub const _IO_EOF_SEEN : u32 = 16 ; pub const _IO_ERR_SEEN : u32 = 32 ; pub const _IO_DELETE_DONT_CLOSE : u32 = 64 ; pub const _IO_LINKED : u32 = 128 ; pub const _IO_IN_BACKUP : u32 = 256 ; pub const _IO_LINE_BUF : u32 = 512 ; pub const _IO_TIED_PUT_GET : u32 = 1024 ; pub const _IO_CURRENTLY_PUTTING : u32 = 2048 ; pub const _IO_IS_APPENDING : u32 = 4096 ; pub const _IO_IS_FILEBUF : u32 = 8192 ; pub const _IO_BAD_SEEN : u32 = 16384 ; pub const _IO_USER_LOCK : u32 = 32768 ; pub const _IO_FLAGS2_MMAP : u32 = 1 ; pub const _IO_FLAGS2_NOTCANCEL : u32 = 2 ; pub const _IO_FLAGS2_USER_WBUF : u32 = 8 ; pub const _IO_SKIPWS : u32 = 1 ; pub const _IO_LEFT : u32 = 2 ; pub const _IO_RIGHT : u32 = 4 ; pub const _IO_INTERNAL : u32 = 8 ; pub const _IO_DEC : u32 = 16 ; pub const _IO_OCT : u32 = 32 ; pub const _IO_HEX : u32 = 64 ; pub const _IO_SHOWBASE : u32 = 128 ; pub const _IO_SHOWPOINT : u32 = 256 ; pub const _IO_UPPERCASE : u32 = 512 ; pub const _IO_SHOWPOS : u32 = 1024 ; pub const _IO_SCIENTIFIC : u32 = 2048 ; pub const _IO_FIXED : u32 = 4096 ; pub const _IO_UNITBUF : u32 = 8192 ; pub const _IO_STDIO : u32 = 16384 ; pub const _IO_DONT_CLOSE : u32 = 32768 ; pub const _IO_BOOLALPHA : u32 = 65536 ; pub const _IOFBF : u32 = 0 ; pub const _IOLBF : u32 = 1 ; pub const _IONBF : u32 = 2 ; pub const BUFSIZ : u32 = 8192 ; pub const SEEK_SET : u32 = 0 ; pub const SEEK_CUR : u32 = 1 ; pub const SEEK_END : u32 = 2 ; pub const P_tmpdir : & 'static [ u8 ; 5usize ] = b"/tmp\0" ; pub const _BITS_STDIO_LIM_H : u32 = 1 ; pub const L_tmpnam : u32 = 20 ; pub const TMP_MAX : u32 = 238328 ; pub const FILENAME_MAX : u32 = 4096 ; pub const L_ctermid : u32 = 9 ; pub const FOPEN_MAX : u32 = 16 ; pub type wchar_t = :: std :: os :: raw :: c_int ; 
 /// Callback function for a custom allocator.
///
/// HawkTracer requires only one function, which depending on
/// parameter values, performs: alloc, free, and realloc operations.
///
/// To allocate memory, @p ptr must be NULL.
/// To free memory, @p size must be equal to 0.
/// To realloc memory, @p size must be greater than 0, and @p ptr must not
/// be NULL.
///
/// @param ptr a pointer to a memory block for alloc/realloc/free operations.
/// @param size a size of memory block to allocate for alloc/realloc operations.
/// @param user_data an user data specified in ht_allocator_set().
///
/// @return a pointer to allocated memory block for alloc/realloc operations. 
 pub type realloc_function = :: std :: option :: Option < unsafe extern "C" fn ( ptr : * mut :: std :: os :: raw :: c_void , size : usize , user_data : * mut :: std :: os :: raw :: c_void ) -> * mut :: std :: os :: raw :: c_void > ; extern "C" { 
 /// Sets a global allocator for HawkTracer library.
///
/// The allocator is used for every allocation in the library. The function
/// must be called before ht_init() function call.
/// If custom allocator is not specified, default allocator will be used.
///
/// @param func an allocation function.
/// @param user_data an opaque pointer passed to the allocator as a last argument. 
 pub fn ht_allocator_set ( func : realloc_function , user_data : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { 
 /// Allocates memory using HawkTracer allocator.
///
/// @param size a number of bytes to allocate.
///
/// @return a pointer to allocated memory. 
 pub fn ht_alloc ( size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { 
 /// Changes the size of the memory block.
///
/// @param ptr a pointer to the memory block.
/// @param size new size of the memory block.
///
/// @return a pointer to reallocated memory. 
 pub fn ht_realloc ( ptr : * mut :: std :: os :: raw :: c_void , size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { 
 /// Releases memory allocated by ht_alloc.
///
/// @param ptr a pointer to the memory block to release. 
 pub fn ht_free ( ptr : * mut :: std :: os :: raw :: c_void ) ; } pub const MKCREFLECT_Types_MKCREFLECT_TYPES_STRUCT : MKCREFLECT_Types = 1 ; pub const MKCREFLECT_Types_MKCREFLECT_TYPES_STRING : MKCREFLECT_Types = 2 ; pub const MKCREFLECT_Types_MKCREFLECT_TYPES_INTEGER : MKCREFLECT_Types = 3 ; pub const MKCREFLECT_Types_MKCREFLECT_TYPES_FLOAT : MKCREFLECT_Types = 4 ; pub const MKCREFLECT_Types_MKCREFLECT_TYPES_DOUBLE : MKCREFLECT_Types = 5 ; pub const MKCREFLECT_Types_MKCREFLECT_TYPES_POINTER : MKCREFLECT_Types = 6 ; pub type MKCREFLECT_Types = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _MKCREFLECT_FieldInfo { pub field_type : * const :: std :: os :: raw :: c_char , pub field_name : * const :: std :: os :: raw :: c_char , pub size : usize , pub offset : usize , pub is_signed : :: std :: os :: raw :: c_int , pub array_size : :: std :: os :: raw :: c_int , pub data_type : MKCREFLECT_Types , } # [ test ] fn bindgen_test_layout__MKCREFLECT_FieldInfo ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _MKCREFLECT_FieldInfo > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( _MKCREFLECT_FieldInfo ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _MKCREFLECT_FieldInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _MKCREFLECT_FieldInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_FieldInfo > ( ) ) ) . field_type as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_FieldInfo ) , "::" , stringify ! ( field_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_FieldInfo > ( ) ) ) . field_name as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_FieldInfo ) , "::" , stringify ! ( field_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_FieldInfo > ( ) ) ) . size as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_FieldInfo ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_FieldInfo > ( ) ) ) . offset as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_FieldInfo ) , "::" , stringify ! ( offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_FieldInfo > ( ) ) ) . is_signed as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_FieldInfo ) , "::" , stringify ! ( is_signed ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_FieldInfo > ( ) ) ) . array_size as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_FieldInfo ) , "::" , stringify ! ( array_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_FieldInfo > ( ) ) ) . data_type as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_FieldInfo ) , "::" , stringify ! ( data_type ) ) ) ; } pub type MKCREFLECT_FieldInfo = _MKCREFLECT_FieldInfo ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _MKCREFLECT_TypeInfo { pub name : * const :: std :: os :: raw :: c_char , pub fields_count : usize , pub size : usize , pub packed_size : usize , pub fields : * mut MKCREFLECT_FieldInfo , } # [ test ] fn bindgen_test_layout__MKCREFLECT_TypeInfo ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _MKCREFLECT_TypeInfo > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( _MKCREFLECT_TypeInfo ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _MKCREFLECT_TypeInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _MKCREFLECT_TypeInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_TypeInfo > ( ) ) ) . name as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_TypeInfo ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_TypeInfo > ( ) ) ) . fields_count as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_TypeInfo ) , "::" , stringify ! ( fields_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_TypeInfo > ( ) ) ) . size as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_TypeInfo ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_TypeInfo > ( ) ) ) . packed_size as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_TypeInfo ) , "::" , stringify ! ( packed_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _MKCREFLECT_TypeInfo > ( ) ) ) . fields as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( _MKCREFLECT_TypeInfo ) , "::" , stringify ! ( fields ) ) ) ; } pub type MKCREFLECT_TypeInfo = _MKCREFLECT_TypeInfo ; pub type __u_char = :: std :: os :: raw :: c_uchar ; pub type __u_short = :: std :: os :: raw :: c_ushort ; pub type __u_int = :: std :: os :: raw :: c_uint ; pub type __u_long = :: std :: os :: raw :: c_ulong ; pub type __int8_t = :: std :: os :: raw :: c_schar ; pub type __uint8_t = :: std :: os :: raw :: c_uchar ; pub type __int16_t = :: std :: os :: raw :: c_short ; pub type __uint16_t = :: std :: os :: raw :: c_ushort ; pub type __int32_t = :: std :: os :: raw :: c_int ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __int64_t = :: std :: os :: raw :: c_long ; pub type __uint64_t = :: std :: os :: raw :: c_ulong ; pub type __quad_t = :: std :: os :: raw :: c_long ; pub type __u_quad_t = :: std :: os :: raw :: c_ulong ; pub type __intmax_t = :: std :: os :: raw :: c_long ; pub type __uintmax_t = :: std :: os :: raw :: c_ulong ; pub type __dev_t = :: std :: os :: raw :: c_ulong ; pub type __uid_t = :: std :: os :: raw :: c_uint ; pub type __gid_t = :: std :: os :: raw :: c_uint ; pub type __ino_t = :: std :: os :: raw :: c_ulong ; pub type __ino64_t = :: std :: os :: raw :: c_ulong ; pub type __mode_t = :: std :: os :: raw :: c_uint ; pub type __nlink_t = :: std :: os :: raw :: c_ulong ; pub type __off_t = :: std :: os :: raw :: c_long ; pub type __off64_t = :: std :: os :: raw :: c_long ; pub type __pid_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __fsid_t { pub __val : [ :: std :: os :: raw :: c_int ; 2usize ] , } # [ test ] fn bindgen_test_layout___fsid_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __fsid_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __fsid_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __fsid_t > ( ) ) ) . __val as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __fsid_t ) , "::" , stringify ! ( __val ) ) ) ; } pub type __clock_t = :: std :: os :: raw :: c_long ; pub type __rlim_t = :: std :: os :: raw :: c_ulong ; pub type __rlim64_t = :: std :: os :: raw :: c_ulong ; pub type __id_t = :: std :: os :: raw :: c_uint ; pub type __time_t = :: std :: os :: raw :: c_long ; pub type __useconds_t = :: std :: os :: raw :: c_uint ; pub type __suseconds_t = :: std :: os :: raw :: c_long ; pub type __daddr_t = :: std :: os :: raw :: c_int ; pub type __key_t = :: std :: os :: raw :: c_int ; pub type __clockid_t = :: std :: os :: raw :: c_int ; pub type __timer_t = * mut :: std :: os :: raw :: c_void ; pub type __blksize_t = :: std :: os :: raw :: c_long ; pub type __blkcnt_t = :: std :: os :: raw :: c_long ; pub type __blkcnt64_t = :: std :: os :: raw :: c_long ; pub type __fsblkcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsblkcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsword_t = :: std :: os :: raw :: c_long ; pub type __ssize_t = :: std :: os :: raw :: c_long ; pub type __syscall_slong_t = :: std :: os :: raw :: c_long ; pub type __syscall_ulong_t = :: std :: os :: raw :: c_ulong ; pub type __loff_t = __off64_t ; pub type __caddr_t = * mut :: std :: os :: raw :: c_char ; pub type __intptr_t = :: std :: os :: raw :: c_long ; pub type __socklen_t = :: std :: os :: raw :: c_uint ; pub type __sig_atomic_t = :: std :: os :: raw :: c_int ; pub type int_least8_t = :: std :: os :: raw :: c_schar ; pub type int_least16_t = :: std :: os :: raw :: c_short ; pub type int_least32_t = :: std :: os :: raw :: c_int ; pub type int_least64_t = :: std :: os :: raw :: c_long ; pub type uint_least8_t = :: std :: os :: raw :: c_uchar ; pub type uint_least16_t = :: std :: os :: raw :: c_ushort ; pub type uint_least32_t = :: std :: os :: raw :: c_uint ; pub type uint_least64_t = :: std :: os :: raw :: c_ulong ; pub type int_fast8_t = :: std :: os :: raw :: c_schar ; pub type int_fast16_t = :: std :: os :: raw :: c_long ; pub type int_fast32_t = :: std :: os :: raw :: c_long ; pub type int_fast64_t = :: std :: os :: raw :: c_long ; pub type uint_fast8_t = :: std :: os :: raw :: c_uchar ; pub type uint_fast16_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast32_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast64_t = :: std :: os :: raw :: c_ulong ; pub type intmax_t = __intmax_t ; pub type uintmax_t = __uintmax_t ; pub type __gwchar_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct imaxdiv_t { pub quot : :: std :: os :: raw :: c_long , pub rem : :: std :: os :: raw :: c_long , } # [ test ] fn bindgen_test_layout_imaxdiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < imaxdiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( imaxdiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < imaxdiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( imaxdiv_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < imaxdiv_t > ( ) ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( imaxdiv_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < imaxdiv_t > ( ) ) ) . rem as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( imaxdiv_t ) , "::" , stringify ! ( rem ) ) ) ; } extern "C" { pub fn imaxabs ( __n : intmax_t ) -> intmax_t ; } extern "C" { pub fn imaxdiv ( __numer : intmax_t , __denom : intmax_t ) -> imaxdiv_t ; } extern "C" { pub fn strtoimax ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> intmax_t ; } extern "C" { pub fn strtoumax ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> uintmax_t ; } extern "C" { pub fn wcstoimax ( __nptr : * const __gwchar_t , __endptr : * mut * mut __gwchar_t , __base : :: std :: os :: raw :: c_int ) -> intmax_t ; } extern "C" { pub fn wcstoumax ( __nptr : * const __gwchar_t , __endptr : * mut * mut __gwchar_t , __base : :: std :: os :: raw :: c_int ) -> uintmax_t ; } 
 /// An unsigned integer used for event klass identifiers. 
 pub type HT_EventKlassId = u32 ; 
 /// An unsigned integer used for representing timestamps in nanoseconds. 
 pub type HT_TimestampNs = u64 ; 
 /// An unsigned integer used for event identifiers. 
 pub type HT_EventId = u64 ; 
 /// An unsigned integer used for representing duration in nanoseconds. 
 pub type HT_DurationNs = u64 ; 
 /// A standard boolean type, possible values: #HT_TRUE, #HT_FALSE 
 pub type HT_Boolean = :: std :: os :: raw :: c_int ; 
 /// A pointer to a list of HT_Event (or derived) objects. 
 pub type TEventPtr = * mut u8 ; 
 /// An unsigned integer used for thread identifiers. 
 pub type HT_ThreadId = u32 ; 
 /// An unsigned integer guaranteed to be 8 bits on all platforms. 
 pub type HT_Byte = u8 ; 
 /// No error 
 pub const HT_ErrorCode_HT_ERR_OK : HT_ErrorCode = 0 ; 
 /// Memory allocation failed. This is very serious error, and
/// most likely your entire application is broken at this point of time. 
 pub const HT_ErrorCode_HT_ERR_OUT_OF_MEMORY : HT_ErrorCode = 1 ; 
 /// Try to register a timeline feature using ID which is already taken
/// by some other feature. 
 pub const HT_ErrorCode_HT_ERR_FEATURE_ALREADY_REGISTERED : HT_ErrorCode = 2 ; 
 /// Try to register container with name already used in registry.
/// This error is used internally, and is never returned by public
/// API. TODO: consider removing it from public enum. 
 pub const HT_ErrorCode_HT_ERR_LISTENER_CONTAINER_ALREADY_REGISTERED : HT_ErrorCode = 3 ; 
 /// Cannot open file. 
 pub const HT_ErrorCode_HT_ERR_CANT_OPEN_FILE : HT_ErrorCode = 4 ; 
 /// Cannot start tcp server. This error might have many root causes,
/// some of them are: socket can't be open, library is not able to bind to a port. 
 pub const HT_ErrorCode_HT_ERR_CANT_START_TCP_SERVER : HT_ErrorCode = 5 ; 
 /// Unable to create listener container. This is most likely caused by
/// #HT_ERR_OUT_OF_MEMORY occured internally in the library. 
 pub const HT_ErrorCode_HT_ERR_CANT_CREATE_LISTENER_CONTAINER : HT_ErrorCode = 6 ; 
 /// Format of an input data is invalid. 
 pub const HT_ErrorCode_HT_ERR_INVALID_FORMAT : HT_ErrorCode = 7 ; 
 /// Defines list of possible errors returned by library functions. 
 pub type HT_ErrorCode = u32 ; 
 /// Little-endian order. 
 pub const HT_Endianness_HT_ENDIANNESS_LITTLE : HT_Endianness = 0 ; 
 /// Big-endian order. 
 pub const HT_Endianness_HT_ENDIANNESS_BIG : HT_Endianness = 1 ; 
 /// Defines supported byte ordering 
 pub type HT_Endianness = u32 ; 
 /// Data type struct. 
 pub const HT_MKCREFLECT_Types_Ext_HT_MKCREFLECT_TYPES_EXT_STRUCT : HT_MKCREFLECT_Types_Ext = 1 ; 
 /// Data type string. 
 pub const HT_MKCREFLECT_Types_Ext_HT_MKCREFLECT_TYPES_EXT_STRING : HT_MKCREFLECT_Types_Ext = 2 ; 
 /// Data type integer. 
 pub const HT_MKCREFLECT_Types_Ext_HT_MKCREFLECT_TYPES_EXT_INTEGER : HT_MKCREFLECT_Types_Ext = 3 ; 
 /// Data type float. 
 pub const HT_MKCREFLECT_Types_Ext_HT_MKCREFLECT_TYPES_EXT_FLOAT : HT_MKCREFLECT_Types_Ext = 4 ; 
 /// Data type double. 
 pub const HT_MKCREFLECT_Types_Ext_HT_MKCREFLECT_TYPES_EXT_DOUBLE : HT_MKCREFLECT_Types_Ext = 5 ; 
 /// Data type pointer. 
 pub const HT_MKCREFLECT_Types_Ext_HT_MKCREFLECT_TYPES_EXT_POINTER : HT_MKCREFLECT_Types_Ext = 6 ; 
 /// Data type unsigned integer. 
 pub const HT_MKCREFLECT_Types_Ext_HT_MKCREFLECT_TYPES_EXT_UNSIGNED_INTEGER : HT_MKCREFLECT_Types_Ext = 99 ; 
 /// Defines list of data types of event fields. 
 pub type HT_MKCREFLECT_Types_Ext = u32 ; pub type HT_EventKlass = _HT_EventKlass ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HT_Event { pub klass : * mut HT_EventKlass , pub timestamp : HT_TimestampNs , pub id : HT_EventId , } # [ test ] fn bindgen_test_layout_HT_Event ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HT_Event > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( HT_Event ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HT_Event > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( HT_Event ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_Event > ( ) ) ) . klass as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HT_Event ) , "::" , stringify ! ( klass ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_Event > ( ) ) ) . timestamp as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( HT_Event ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_Event > ( ) ) ) . id as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( HT_Event ) , "::" , stringify ! ( id ) ) ) ; } extern "C" { pub fn mkcreflect_get_HT_Event_type_info ( ) -> * mut MKCREFLECT_TypeInfo ; } extern "C" { pub fn ht_HT_Event_get_event_klass_instance ( ) -> * mut HT_EventKlass ; } extern "C" { pub fn ht_HT_Event_register_event_klass ( ) -> HT_EventKlassId ; } extern "C" { pub fn ht_HT_Event_get_size ( event : * mut HT_Event ) -> usize ; } extern "C" { pub fn ht_HT_Event_fnc_serialize ( event : * mut HT_Event , buffer : * mut HT_Byte ) -> usize ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _HT_EventKlass { pub type_info : * mut MKCREFLECT_TypeInfo , pub serialize : :: std :: option :: Option < unsafe extern "C" fn ( event : * mut HT_Event , buffer : * mut HT_Byte ) -> usize > , pub get_size : :: std :: option :: Option < unsafe extern "C" fn ( event : * mut HT_Event ) -> usize > , pub klass_id : HT_EventKlassId , } # [ test ] fn bindgen_test_layout__HT_EventKlass ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _HT_EventKlass > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( _HT_EventKlass ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _HT_EventKlass > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _HT_EventKlass ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _HT_EventKlass > ( ) ) ) . type_info as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _HT_EventKlass ) , "::" , stringify ! ( type_info ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _HT_EventKlass > ( ) ) ) . serialize as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _HT_EventKlass ) , "::" , stringify ! ( serialize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _HT_EventKlass > ( ) ) ) . get_size as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _HT_EventKlass ) , "::" , stringify ! ( get_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _HT_EventKlass > ( ) ) ) . klass_id as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _HT_EventKlass ) , "::" , stringify ! ( klass_id ) ) ) ; } extern "C" { 
 /// Gets a current timestamp of a monotonic clock.
///
/// The timestamp of this clock can not decrease as physical
/// time moves forward. Although the timestamp doesn't represent wall
/// clock time, returned values can be used e.g. for measuring
/// intervals.
///
/// @return a current timestamp of the clock. 
 pub fn ht_monotonic_clock_get_timestamp ( ) -> HT_TimestampNs ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _HT_TimelineListenerContainer { _unused : [ u8 ; 0 ] , } pub type HT_TimelineListenerContainer = _HT_TimelineListenerContainer ; pub type HT_TimelineListenerCallback = :: std :: option :: Option < unsafe extern "C" fn ( events : TEventPtr , event_count : usize , serialized : HT_Boolean , user_data : * mut :: std :: os :: raw :: c_void ) > ; extern "C" { 
 /// Pushes all metadata events (registry klasses, system information) to a listener.
/// @param callback a listener callback.
/// @param listener a pointer to the listener
/// @param serialize indicates whether events should be serialized before pushing to listener or not.
///
/// @return number of bytes which have been pushed to a listener. 
 pub fn ht_timeline_listener_push_metadata ( callback : HT_TimelineListenerCallback , listener : * mut :: std :: os :: raw :: c_void , serialize : HT_Boolean ) -> usize ; } extern "C" { pub fn ht_timeline_listener_container_create ( ) -> * mut HT_TimelineListenerContainer ; } extern "C" { pub fn ht_timeline_listener_container_unref ( container : * mut HT_TimelineListenerContainer ) ; } extern "C" { 
 /// Registers new listener to a container.
///
/// @param container a pointer to the container.
/// @param callback a timeline listener callback.
/// @param user_data a user data passed to a @a callback when gets called.
///
/// @returns #HT_ERR_OK, if registration completed successfully; otherwise, appropriate error code. 
 pub fn ht_timeline_listener_container_register_listener ( container : * mut HT_TimelineListenerContainer , callback : HT_TimelineListenerCallback , user_data : * mut :: std :: os :: raw :: c_void ) -> HT_ErrorCode ; } extern "C" { 
 /// Removes all timeline listeners from the container.
///
/// @param container a pointer to the container. 
 pub fn ht_timeline_listener_container_unregister_all_listeners ( container : * mut HT_TimelineListenerContainer ) ; } extern "C" { 
 /// Finds an container in a global registry or create one if container doesn't exist.
///
/// If @a name is NULL, this method always returns new container.
///
/// @param name a name of the container to find/create.
///
/// @return a pointer to a container. 
 pub fn ht_find_or_create_listener ( name : * const :: std :: os :: raw :: c_char ) -> * mut HT_TimelineListenerContainer ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _HT_EventIdProvider { _unused : [ u8 ; 0 ] , } 
 /// HT_EventIdProvider is a sequence number generator. It starts
/// the sequence from 0. Every next call of ht_event_id_provider_next()
/// increments the identifier. 
 pub type HT_EventIdProvider = _HT_EventIdProvider ; extern "C" { 
 /// Gets default provider.
///
/// Default ID provider is currently used for all the timelines.
///
/// @return a pointer to the default ID provider. 
 pub fn ht_event_id_provider_get_default ( ) -> * mut HT_EventIdProvider ; } extern "C" { 
 /// Creates a new instance of an ID provider.
///
/// @return a pointer to the new ID provider. 
 pub fn ht_event_id_provider_create ( ) -> * mut HT_EventIdProvider ; } extern "C" { 
 /// Destroys a provider.
/// @param provider a provider to destroy. 
 pub fn ht_event_id_provider_destroy ( provider : * mut HT_EventIdProvider ) ; } extern "C" { 
 /// Gets next identifier.
///
/// @param provider a provider.
///
/// @return next identifier from the @p provider. 
 pub fn ht_event_id_provider_next ( provider : * mut HT_EventIdProvider ) -> HT_EventId ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _HT_Timeline { _unused : [ u8 ; 0 ] , } pub type HT_Timeline = _HT_Timeline ; extern "C" { pub fn ht_timeline_create ( buffer_capacity : usize , thread_safe : HT_Boolean , serialize_events : HT_Boolean , listeners : * const :: std :: os :: raw :: c_char , out_err : * mut HT_ErrorCode ) -> * mut HT_Timeline ; } extern "C" { pub fn ht_timeline_destroy ( timeline : * mut HT_Timeline ) ; } extern "C" { pub fn ht_timeline_register_listener ( timeline : * mut HT_Timeline , callback : HT_TimelineListenerCallback , user_data : * mut :: std :: os :: raw :: c_void ) -> HT_ErrorCode ; } extern "C" { pub fn ht_timeline_unregister_all_listeners ( timeline : * mut HT_Timeline ) ; } extern "C" { pub fn ht_timeline_init_event ( timeline : * mut HT_Timeline , event : * mut HT_Event ) ; } extern "C" { pub fn ht_timeline_push_event ( timeline : * mut HT_Timeline , event : * mut HT_Event ) ; } extern "C" { pub fn ht_timeline_flush ( timeline : * mut HT_Timeline ) ; } extern "C" { pub fn ht_timeline_set_feature ( timeline : * mut HT_Timeline , feature_id : usize , feature : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { pub fn ht_timeline_get_feature ( timeline : * mut HT_Timeline , feature_id : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn ht_timeline_get_id_provider ( timeline : * mut HT_Timeline ) -> * mut HT_EventIdProvider ; } 
 /// A type of a callback which gets called when a timeline disables the feature. 
 pub type HT_FeatureDisableCallback = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut HT_Timeline ) > ; extern "C" { 
 /// Registers new a new feature in the system.
///
/// @param feature_id a feature identifier.
/// @param disable_callback a function which gets called when timeline disables the feature.
///
/// @returns #HT_ERR_OK, if registration completed successfully; otherwise, appropriate error code. 
 pub fn ht_registry_register_feature ( feature_id : u32 , disable_callback : HT_FeatureDisableCallback ) -> HT_ErrorCode ; } extern "C" { 
 /// Registers new event klass in the system, or gets identifier if klass is already registered.
///
/// @param event_klass a pointer to a klass definition.
///
/// @return an identifier to a klass, or #HT_INVALID_KLASS_ID if registration failed. 
 pub fn ht_registry_register_event_klass ( event_klass : * mut HT_EventKlass ) -> HT_EventKlassId ; } extern "C" { 
 /// Pushes information about registered event klasses (HT_EventKlassInfoEvent and HT_EventKlassFieldInfoEvent events) directly to a listener.
///
/// @param callback the listener callback.
/// @param listener a pointer to the listener.
/// @param serialize indicates whether events should be serialized before pushing to listener or not.
///
/// @return number of bytes which have been pushed to a listener. 
 pub fn ht_registry_push_registry_klasses_to_listener ( callback : HT_TimelineListenerCallback , listener : * mut :: std :: os :: raw :: c_void , serialize : HT_Boolean ) -> usize ; } extern "C" { pub fn ht_registry_get_event_klasses ( out_klass_count : * mut usize ) -> * mut * mut HT_EventKlass ; } extern "C" { pub fn memcpy ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memmove ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memccpy ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memset ( __s : * mut :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memcmp ( __s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn memchr ( __s : * const :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn strcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcat ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strncat ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strncmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strcoll ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strxfrm ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_ulong ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __locale_struct { pub __locales : [ * mut __locale_data ; 13usize ] , pub __ctype_b : * const :: std :: os :: raw :: c_ushort , pub __ctype_tolower : * const :: std :: os :: raw :: c_int , pub __ctype_toupper : * const :: std :: os :: raw :: c_int , pub __names : [ * const :: std :: os :: raw :: c_char ; 13usize ] , } # [ test ] fn bindgen_test_layout___locale_struct ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __locale_struct > ( ) , 232usize , concat ! ( "Size of: " , stringify ! ( __locale_struct ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __locale_struct > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __locale_struct ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __locales as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __locales ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __ctype_b as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_b ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __ctype_tolower as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_tolower ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __ctype_toupper as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_toupper ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __names as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __names ) ) ) ; } pub type __locale_t = * mut __locale_struct ; pub type locale_t = __locale_t ; extern "C" { pub fn strcoll_l ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __l : locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strxfrm_l ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize , __l : locale_t ) -> usize ; } extern "C" { pub fn strdup ( __s : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strndup ( __string : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strchr ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strrchr ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcspn ( __s : * const :: std :: os :: raw :: c_char , __reject : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn strspn ( __s : * const :: std :: os :: raw :: c_char , __accept : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn strpbrk ( __s : * const :: std :: os :: raw :: c_char , __accept : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strstr ( __haystack : * const :: std :: os :: raw :: c_char , __needle : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strtok ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __strtok_r ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , __save_ptr : * mut * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strtok_r ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , __save_ptr : * mut * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strlen ( __s : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn strnlen ( __string : * const :: std :: os :: raw :: c_char , __maxlen : usize ) -> usize ; } extern "C" { pub fn strerror ( __errnum : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}__xpg_strerror_r" ] pub fn strerror_r ( __errnum : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strerror_l ( __errnum : :: std :: os :: raw :: c_int , __l : locale_t ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn bcmp ( __s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn bcopy ( __src : * const :: std :: os :: raw :: c_void , __dest : * mut :: std :: os :: raw :: c_void , __n : usize ) ; } extern "C" { pub fn bzero ( __s : * mut :: std :: os :: raw :: c_void , __n : usize ) ; } extern "C" { pub fn index ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn rindex ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn ffs ( __i : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ffsl ( __l : :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ffsll ( __ll : :: std :: os :: raw :: c_longlong ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strcasecmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strncasecmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strcasecmp_l ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __loc : locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strncasecmp_l ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : usize , __loc : locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn explicit_bzero ( __s : * mut :: std :: os :: raw :: c_void , __n : usize ) ; } extern "C" { pub fn strsep ( __stringp : * mut * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strsignal ( __sig : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __stpcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn stpcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __stpncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn stpncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HT_EndiannessInfoEvent { pub base : HT_Event , pub endianness : u8 , } # [ test ] fn bindgen_test_layout_HT_EndiannessInfoEvent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HT_EndiannessInfoEvent > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( HT_EndiannessInfoEvent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HT_EndiannessInfoEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( HT_EndiannessInfoEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EndiannessInfoEvent > ( ) ) ) . base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HT_EndiannessInfoEvent ) , "::" , stringify ! ( base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EndiannessInfoEvent > ( ) ) ) . endianness as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( HT_EndiannessInfoEvent ) , "::" , stringify ! ( endianness ) ) ) ; } extern "C" { pub fn mkcreflect_get_HT_EndiannessInfoEvent_type_info ( ) -> * mut MKCREFLECT_TypeInfo ; } extern "C" { pub fn ht_HT_EndiannessInfoEvent_get_size ( VAR_NAME : * mut HT_Event ) -> usize ; } extern "C" { pub fn ht_HT_EndiannessInfoEvent_fnc_serialize ( VAR_NAME_ : * mut HT_Event , buffer : * mut HT_Byte ) -> usize ; } extern "C" { pub fn ht_HT_EndiannessInfoEvent_get_event_klass_instance ( ) -> * mut HT_EventKlass ; } extern "C" { pub fn ht_HT_EndiannessInfoEvent_register_event_klass ( ) -> HT_EventKlassId ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HT_EventKlassInfoEvent { pub base : HT_Event , pub info_klass_id : HT_EventKlassId , pub event_klass_name : * const :: std :: os :: raw :: c_char , pub field_count : u8 , } # [ test ] fn bindgen_test_layout_HT_EventKlassInfoEvent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HT_EventKlassInfoEvent > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( HT_EventKlassInfoEvent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HT_EventKlassInfoEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( HT_EventKlassInfoEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassInfoEvent > ( ) ) ) . base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassInfoEvent ) , "::" , stringify ! ( base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassInfoEvent > ( ) ) ) . info_klass_id as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassInfoEvent ) , "::" , stringify ! ( info_klass_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassInfoEvent > ( ) ) ) . event_klass_name as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassInfoEvent ) , "::" , stringify ! ( event_klass_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassInfoEvent > ( ) ) ) . field_count as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassInfoEvent ) , "::" , stringify ! ( field_count ) ) ) ; } extern "C" { pub fn mkcreflect_get_HT_EventKlassInfoEvent_type_info ( ) -> * mut MKCREFLECT_TypeInfo ; } extern "C" { pub fn ht_HT_EventKlassInfoEvent_get_size ( VAR_NAME : * mut HT_Event ) -> usize ; } extern "C" { pub fn ht_HT_EventKlassInfoEvent_fnc_serialize ( VAR_NAME_ : * mut HT_Event , buffer : * mut HT_Byte ) -> usize ; } extern "C" { pub fn ht_HT_EventKlassInfoEvent_get_event_klass_instance ( ) -> * mut HT_EventKlass ; } extern "C" { pub fn ht_HT_EventKlassInfoEvent_register_event_klass ( ) -> HT_EventKlassId ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HT_EventKlassFieldInfoEvent { pub base : HT_Event , pub info_klass_id : HT_EventKlassId , pub field_type : * const :: std :: os :: raw :: c_char , pub field_name : * const :: std :: os :: raw :: c_char , pub size : u64 , pub data_type : u8 , } # [ test ] fn bindgen_test_layout_HT_EventKlassFieldInfoEvent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HT_EventKlassFieldInfoEvent > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( HT_EventKlassFieldInfoEvent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HT_EventKlassFieldInfoEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( HT_EventKlassFieldInfoEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassFieldInfoEvent > ( ) ) ) . base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassFieldInfoEvent ) , "::" , stringify ! ( base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassFieldInfoEvent > ( ) ) ) . info_klass_id as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassFieldInfoEvent ) , "::" , stringify ! ( info_klass_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassFieldInfoEvent > ( ) ) ) . field_type as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassFieldInfoEvent ) , "::" , stringify ! ( field_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassFieldInfoEvent > ( ) ) ) . field_name as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassFieldInfoEvent ) , "::" , stringify ! ( field_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassFieldInfoEvent > ( ) ) ) . size as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassFieldInfoEvent ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_EventKlassFieldInfoEvent > ( ) ) ) . data_type as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( HT_EventKlassFieldInfoEvent ) , "::" , stringify ! ( data_type ) ) ) ; } extern "C" { pub fn mkcreflect_get_HT_EventKlassFieldInfoEvent_type_info ( ) -> * mut MKCREFLECT_TypeInfo ; } extern "C" { pub fn ht_HT_EventKlassFieldInfoEvent_get_size ( VAR_NAME : * mut HT_Event ) -> usize ; } extern "C" { pub fn ht_HT_EventKlassFieldInfoEvent_fnc_serialize ( VAR_NAME_ : * mut HT_Event , buffer : * mut HT_Byte ) -> usize ; } extern "C" { pub fn ht_HT_EventKlassFieldInfoEvent_get_event_klass_instance ( ) -> * mut HT_EventKlass ; } extern "C" { pub fn ht_HT_EventKlassFieldInfoEvent_register_event_klass ( ) -> HT_EventKlassId ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HT_CallstackBaseEvent { pub base : HT_Event , pub duration : HT_DurationNs , pub thread_id : HT_ThreadId , } # [ test ] fn bindgen_test_layout_HT_CallstackBaseEvent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HT_CallstackBaseEvent > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( HT_CallstackBaseEvent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HT_CallstackBaseEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( HT_CallstackBaseEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_CallstackBaseEvent > ( ) ) ) . base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HT_CallstackBaseEvent ) , "::" , stringify ! ( base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_CallstackBaseEvent > ( ) ) ) . duration as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( HT_CallstackBaseEvent ) , "::" , stringify ! ( duration ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_CallstackBaseEvent > ( ) ) ) . thread_id as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( HT_CallstackBaseEvent ) , "::" , stringify ! ( thread_id ) ) ) ; } extern "C" { pub fn mkcreflect_get_HT_CallstackBaseEvent_type_info ( ) -> * mut MKCREFLECT_TypeInfo ; } extern "C" { pub fn ht_HT_CallstackBaseEvent_get_size ( VAR_NAME : * mut HT_Event ) -> usize ; } extern "C" { pub fn ht_HT_CallstackBaseEvent_fnc_serialize ( VAR_NAME_ : * mut HT_Event , buffer : * mut HT_Byte ) -> usize ; } extern "C" { pub fn ht_HT_CallstackBaseEvent_get_event_klass_instance ( ) -> * mut HT_EventKlass ; } extern "C" { pub fn ht_HT_CallstackBaseEvent_register_event_klass ( ) -> HT_EventKlassId ; } pub type HT_CallstackEventLabel = u64 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HT_CallstackIntEvent { pub base : HT_CallstackBaseEvent , pub label : HT_CallstackEventLabel , } # [ test ] fn bindgen_test_layout_HT_CallstackIntEvent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HT_CallstackIntEvent > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( HT_CallstackIntEvent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HT_CallstackIntEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( HT_CallstackIntEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_CallstackIntEvent > ( ) ) ) . base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HT_CallstackIntEvent ) , "::" , stringify ! ( base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_CallstackIntEvent > ( ) ) ) . label as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( HT_CallstackIntEvent ) , "::" , stringify ! ( label ) ) ) ; } extern "C" { pub fn mkcreflect_get_HT_CallstackIntEvent_type_info ( ) -> * mut MKCREFLECT_TypeInfo ; } extern "C" { pub fn ht_HT_CallstackIntEvent_get_size ( VAR_NAME : * mut HT_Event ) -> usize ; } extern "C" { pub fn ht_HT_CallstackIntEvent_fnc_serialize ( VAR_NAME_ : * mut HT_Event , buffer : * mut HT_Byte ) -> usize ; } extern "C" { pub fn ht_HT_CallstackIntEvent_get_event_klass_instance ( ) -> * mut HT_EventKlass ; } extern "C" { pub fn ht_HT_CallstackIntEvent_register_event_klass ( ) -> HT_EventKlassId ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HT_CallstackStringEvent { pub base : HT_CallstackBaseEvent , pub label : * const :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_HT_CallstackStringEvent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HT_CallstackStringEvent > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( HT_CallstackStringEvent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HT_CallstackStringEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( HT_CallstackStringEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_CallstackStringEvent > ( ) ) ) . base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HT_CallstackStringEvent ) , "::" , stringify ! ( base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_CallstackStringEvent > ( ) ) ) . label as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( HT_CallstackStringEvent ) , "::" , stringify ! ( label ) ) ) ; } extern "C" { pub fn mkcreflect_get_HT_CallstackStringEvent_type_info ( ) -> * mut MKCREFLECT_TypeInfo ; } extern "C" { pub fn ht_HT_CallstackStringEvent_get_size ( VAR_NAME : * mut HT_Event ) -> usize ; } extern "C" { pub fn ht_HT_CallstackStringEvent_fnc_serialize ( VAR_NAME_ : * mut HT_Event , buffer : * mut HT_Byte ) -> usize ; } extern "C" { pub fn ht_HT_CallstackStringEvent_get_event_klass_instance ( ) -> * mut HT_EventKlass ; } extern "C" { pub fn ht_HT_CallstackStringEvent_register_event_klass ( ) -> HT_EventKlassId ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HT_StringMappingEvent { pub base : HT_Event , pub identifier : u64 , pub label : * const :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_HT_StringMappingEvent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HT_StringMappingEvent > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( HT_StringMappingEvent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HT_StringMappingEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( HT_StringMappingEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_StringMappingEvent > ( ) ) ) . base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HT_StringMappingEvent ) , "::" , stringify ! ( base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_StringMappingEvent > ( ) ) ) . identifier as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( HT_StringMappingEvent ) , "::" , stringify ! ( identifier ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_StringMappingEvent > ( ) ) ) . label as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( HT_StringMappingEvent ) , "::" , stringify ! ( label ) ) ) ; } extern "C" { pub fn mkcreflect_get_HT_StringMappingEvent_type_info ( ) -> * mut MKCREFLECT_TypeInfo ; } extern "C" { pub fn ht_HT_StringMappingEvent_get_size ( VAR_NAME : * mut HT_Event ) -> usize ; } extern "C" { pub fn ht_HT_StringMappingEvent_fnc_serialize ( VAR_NAME_ : * mut HT_Event , buffer : * mut HT_Byte ) -> usize ; } extern "C" { pub fn ht_HT_StringMappingEvent_get_event_klass_instance ( ) -> * mut HT_EventKlass ; } extern "C" { pub fn ht_HT_StringMappingEvent_register_event_klass ( ) -> HT_EventKlassId ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct HT_SystemInfoEvent { pub base : HT_Event , pub version_major : u8 , pub version_minor : u8 , pub version_patch : u8 , } # [ test ] fn bindgen_test_layout_HT_SystemInfoEvent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < HT_SystemInfoEvent > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( HT_SystemInfoEvent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < HT_SystemInfoEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( HT_SystemInfoEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_SystemInfoEvent > ( ) ) ) . base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( HT_SystemInfoEvent ) , "::" , stringify ! ( base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_SystemInfoEvent > ( ) ) ) . version_major as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( HT_SystemInfoEvent ) , "::" , stringify ! ( version_major ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_SystemInfoEvent > ( ) ) ) . version_minor as * const _ as usize } , 25usize , concat ! ( "Offset of field: " , stringify ! ( HT_SystemInfoEvent ) , "::" , stringify ! ( version_minor ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < HT_SystemInfoEvent > ( ) ) ) . version_patch as * const _ as usize } , 26usize , concat ! ( "Offset of field: " , stringify ! ( HT_SystemInfoEvent ) , "::" , stringify ! ( version_patch ) ) ) ; } extern "C" { pub fn mkcreflect_get_HT_SystemInfoEvent_type_info ( ) -> * mut MKCREFLECT_TypeInfo ; } extern "C" { pub fn ht_HT_SystemInfoEvent_get_size ( VAR_NAME : * mut HT_Event ) -> usize ; } extern "C" { pub fn ht_HT_SystemInfoEvent_fnc_serialize ( VAR_NAME_ : * mut HT_Event , buffer : * mut HT_Byte ) -> usize ; } extern "C" { pub fn ht_HT_SystemInfoEvent_get_event_klass_instance ( ) -> * mut HT_EventKlass ; } extern "C" { pub fn ht_HT_SystemInfoEvent_register_event_klass ( ) -> HT_EventKlassId ; } extern "C" { pub fn ht_feature_cached_string_enable ( timeline : * mut HT_Timeline ) -> HT_ErrorCode ; } extern "C" { pub fn ht_feature_cached_string_disable ( timeline : * mut HT_Timeline ) ; } extern "C" { pub fn ht_feature_cached_string_add_mapping ( timeline : * mut HT_Timeline , label : * const :: std :: os :: raw :: c_char ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn ht_feature_cached_string_push_map ( timeline : * mut HT_Timeline ) ; } extern "C" { pub fn ht_feature_callstack_enable ( timeline : * mut HT_Timeline ) -> HT_ErrorCode ; } extern "C" { pub fn ht_feature_callstack_disable ( timeline : * mut HT_Timeline ) ; } extern "C" { pub fn ht_feature_callstack_start ( timeline : * mut HT_Timeline , event : * mut HT_CallstackBaseEvent ) ; } extern "C" { pub fn ht_feature_callstack_stop ( timeline : * mut HT_Timeline ) ; } extern "C" { pub fn ht_feature_callstack_start_int ( timeline : * mut HT_Timeline , label : HT_CallstackEventLabel ) ; } extern "C" { pub fn ht_feature_callstack_start_string ( timeline : * mut HT_Timeline , label : * const :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn _ht_callstack_timeline_scoped_cleanup ( timeline : * mut * mut HT_Timeline ) ; } extern "C" { pub fn _ht_callstack_timeline_int_start_and_ret ( t : * mut HT_Timeline , l : HT_CallstackEventLabel ) -> * mut HT_Timeline ; } extern "C" { pub fn _ht_callstack_timeline_string_start_and_ret ( t : * mut HT_Timeline , l : * const :: std :: os :: raw :: c_char ) -> * mut HT_Timeline ; } pub type time_t = __time_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct timespec { pub tv_sec : __time_t , pub tv_nsec : __syscall_slong_t , } # [ test ] fn bindgen_test_layout_timespec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < timespec > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timespec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < timespec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timespec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < timespec > ( ) ) ) . tv_sec as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_sec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < timespec > ( ) ) ) . tv_nsec as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_nsec ) ) ) ; } pub type pid_t = __pid_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sched_param { pub sched_priority : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_sched_param ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sched_param > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( sched_param ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sched_param > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( sched_param ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < sched_param > ( ) ) ) . sched_priority as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( sched_param ) , "::" , stringify ! ( sched_priority ) ) ) ; } pub type __cpu_mask = :: std :: os :: raw :: c_ulong ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct cpu_set_t { pub __bits : [ __cpu_mask ; 16usize ] , } # [ test ] fn bindgen_test_layout_cpu_set_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < cpu_set_t > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( cpu_set_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < cpu_set_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( cpu_set_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < cpu_set_t > ( ) ) ) . __bits as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( cpu_set_t ) , "::" , stringify ! ( __bits ) ) ) ; } extern "C" { pub fn __sched_cpucount ( __setsize : usize , __setp : * const cpu_set_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __sched_cpualloc ( __count : usize ) -> * mut cpu_set_t ; } extern "C" { pub fn __sched_cpufree ( __set : * mut cpu_set_t ) ; } extern "C" { pub fn sched_setparam ( __pid : __pid_t , __param : * const sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sched_getparam ( __pid : __pid_t , __param : * mut sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sched_setscheduler ( __pid : __pid_t , __policy : :: std :: os :: raw :: c_int , __param : * const sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sched_getscheduler ( __pid : __pid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sched_yield ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sched_get_priority_max ( __algorithm : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sched_get_priority_min ( __algorithm : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sched_rr_get_interval ( __pid : __pid_t , __t : * mut timespec ) -> :: std :: os :: raw :: c_int ; } pub type clock_t = __clock_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct tm { pub tm_sec : :: std :: os :: raw :: c_int , pub tm_min : :: std :: os :: raw :: c_int , pub tm_hour : :: std :: os :: raw :: c_int , pub tm_mday : :: std :: os :: raw :: c_int , pub tm_mon : :: std :: os :: raw :: c_int , pub tm_year : :: std :: os :: raw :: c_int , pub tm_wday : :: std :: os :: raw :: c_int , pub tm_yday : :: std :: os :: raw :: c_int , pub tm_isdst : :: std :: os :: raw :: c_int , pub tm_gmtoff : :: std :: os :: raw :: c_long , pub tm_zone : * const :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_tm ( ) { assert_eq ! ( :: std :: mem :: size_of :: < tm > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( tm ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < tm > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( tm ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < tm > ( ) ) ) . tm_sec as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( tm ) , "::" , stringify ! ( tm_sec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < tm > ( ) ) ) . tm_min as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( tm ) , "::" , stringify ! ( tm_min ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < tm > ( ) ) ) . tm_hour as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( tm ) , "::" , stringify ! ( tm_hour ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < tm > ( ) ) ) . tm_mday as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( tm ) , "::" , stringify ! ( tm_mday ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < tm > ( ) ) ) . tm_mon as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( tm ) , "::" , stringify ! ( tm_mon ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < tm > ( ) ) ) . tm_year as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( tm ) , "::" , stringify ! ( tm_year ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < tm > ( ) ) ) . tm_wday as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( tm ) , "::" , stringify ! ( tm_wday ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < tm > ( ) ) ) . tm_yday as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( tm ) , "::" , stringify ! ( tm_yday ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < tm > ( ) ) ) . tm_isdst as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( tm ) , "::" , stringify ! ( tm_isdst ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < tm > ( ) ) ) . tm_gmtoff as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( tm ) , "::" , stringify ! ( tm_gmtoff ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < tm > ( ) ) ) . tm_zone as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( tm ) , "::" , stringify ! ( tm_zone ) ) ) ; } pub type clockid_t = __clockid_t ; pub type timer_t = __timer_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct itimerspec { pub it_interval : timespec , pub it_value : timespec , } # [ test ] fn bindgen_test_layout_itimerspec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < itimerspec > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( itimerspec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < itimerspec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( itimerspec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < itimerspec > ( ) ) ) . it_interval as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( itimerspec ) , "::" , stringify ! ( it_interval ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < itimerspec > ( ) ) ) . it_value as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( itimerspec ) , "::" , stringify ! ( it_value ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sigevent { _unused : [ u8 ; 0 ] , } extern "C" { pub fn clock ( ) -> clock_t ; } extern "C" { pub fn time ( __timer : * mut time_t ) -> time_t ; } extern "C" { pub fn difftime ( __time1 : time_t , __time0 : time_t ) -> f64 ; } extern "C" { pub fn mktime ( __tp : * mut tm ) -> time_t ; } extern "C" { pub fn strftime ( __s : * mut :: std :: os :: raw :: c_char , __maxsize : usize , __format : * const :: std :: os :: raw :: c_char , __tp : * const tm ) -> usize ; } extern "C" { pub fn strftime_l ( __s : * mut :: std :: os :: raw :: c_char , __maxsize : usize , __format : * const :: std :: os :: raw :: c_char , __tp : * const tm , __loc : locale_t ) -> usize ; } extern "C" { pub fn gmtime ( __timer : * const time_t ) -> * mut tm ; } extern "C" { pub fn localtime ( __timer : * const time_t ) -> * mut tm ; } extern "C" { pub fn gmtime_r ( __timer : * const time_t , __tp : * mut tm ) -> * mut tm ; } extern "C" { pub fn localtime_r ( __timer : * const time_t , __tp : * mut tm ) -> * mut tm ; } extern "C" { pub fn asctime ( __tp : * const tm ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn ctime ( __timer : * const time_t ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn asctime_r ( __tp : * const tm , __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn ctime_r ( __timer : * const time_t , __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}__tzname" ] pub static mut __tzname : [ * mut :: std :: os :: raw :: c_char ; 2usize ] ; } extern "C" { # [ link_name = "\u{1}__daylight" ] pub static mut __daylight : :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__timezone" ] pub static mut __timezone : :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}tzname" ] pub static mut tzname : [ * mut :: std :: os :: raw :: c_char ; 2usize ] ; } extern "C" { pub fn tzset ( ) ; } extern "C" { # [ link_name = "\u{1}daylight" ] pub static mut daylight : :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}timezone" ] pub static mut timezone : :: std :: os :: raw :: c_long ; } extern "C" { pub fn stime ( __when : * const time_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn timegm ( __tp : * mut tm ) -> time_t ; } extern "C" { pub fn timelocal ( __tp : * mut tm ) -> time_t ; } extern "C" { pub fn dysize ( __year : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn nanosleep ( __requested_time : * const timespec , __remaining : * mut timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn clock_getres ( __clock_id : clockid_t , __res : * mut timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn clock_gettime ( __clock_id : clockid_t , __tp : * mut timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn clock_settime ( __clock_id : clockid_t , __tp : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn clock_nanosleep ( __clock_id : clockid_t , __flags : :: std :: os :: raw :: c_int , __req : * const timespec , __rem : * mut timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn clock_getcpuclockid ( __pid : pid_t , __clock_id : * mut clockid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn timer_create ( __clock_id : clockid_t , __evp : * mut sigevent , __timerid : * mut timer_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn timer_delete ( __timerid : timer_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn timer_settime ( __timerid : timer_t , __flags : :: std :: os :: raw :: c_int , __value : * const itimerspec , __ovalue : * mut itimerspec ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn timer_gettime ( __timerid : timer_t , __value : * mut itimerspec ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn timer_getoverrun ( __timerid : timer_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn timespec_get ( __ts : * mut timespec , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_rwlock_arch_t { pub __readers : :: std :: os :: raw :: c_uint , pub __writers : :: std :: os :: raw :: c_uint , pub __wrphase_futex : :: std :: os :: raw :: c_uint , pub __writers_futex : :: std :: os :: raw :: c_uint , pub __pad3 : :: std :: os :: raw :: c_uint , pub __pad4 : :: std :: os :: raw :: c_uint , pub __cur_writer : :: std :: os :: raw :: c_int , pub __shared : :: std :: os :: raw :: c_int , pub __rwelision : :: std :: os :: raw :: c_schar , pub __pad1 : [ :: std :: os :: raw :: c_uchar ; 7usize ] , pub __pad2 : :: std :: os :: raw :: c_ulong , pub __flags : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout___pthread_rwlock_arch_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_rwlock_arch_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( __pthread_rwlock_arch_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_rwlock_arch_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_rwlock_arch_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __readers as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __readers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __writers as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __writers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __wrphase_futex as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __wrphase_futex ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __writers_futex as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __writers_futex ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __pad3 as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __pad3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __pad4 as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __pad4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __cur_writer as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __cur_writer ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __shared as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __shared ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __rwelision as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __rwelision ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __pad1 as * const _ as usize } , 33usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __pad1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __pad2 as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __pad2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_rwlock_arch_t > ( ) ) ) . __flags as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_rwlock_arch_t ) , "::" , stringify ! ( __flags ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_internal_list { pub __prev : * mut __pthread_internal_list , pub __next : * mut __pthread_internal_list , } # [ test ] fn bindgen_test_layout___pthread_internal_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_internal_list > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __pthread_internal_list ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_internal_list > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_internal_list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_internal_list > ( ) ) ) . __prev as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_internal_list > ( ) ) ) . __next as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __next ) ) ) ; } pub type __pthread_list_t = __pthread_internal_list ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_mutex_s { pub __lock : :: std :: os :: raw :: c_int , pub __count : :: std :: os :: raw :: c_uint , pub __owner : :: std :: os :: raw :: c_int , pub __nusers : :: std :: os :: raw :: c_uint , pub __kind : :: std :: os :: raw :: c_int , pub __spins : :: std :: os :: raw :: c_short , pub __elision : :: std :: os :: raw :: c_short , pub __list : __pthread_list_t , } # [ test ] fn bindgen_test_layout___pthread_mutex_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_mutex_s > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( __pthread_mutex_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_mutex_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_mutex_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __lock as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __count as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __owner as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __owner ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __nusers as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __nusers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __kind as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __kind ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __spins as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __spins ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __elision as * const _ as usize } , 22usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __elision ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_mutex_s > ( ) ) ) . __list as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_mutex_s ) , "::" , stringify ! ( __list ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __pthread_cond_s { pub __bindgen_anon_1 : __pthread_cond_s__bindgen_ty_1 , pub __bindgen_anon_2 : __pthread_cond_s__bindgen_ty_2 , pub __g_refs : [ :: std :: os :: raw :: c_uint ; 2usize ] , pub __g_size : [ :: std :: os :: raw :: c_uint ; 2usize ] , pub __g1_orig_size : :: std :: os :: raw :: c_uint , pub __wrefs : :: std :: os :: raw :: c_uint , pub __g_signals : [ :: std :: os :: raw :: c_uint ; 2usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __pthread_cond_s__bindgen_ty_1 { pub __wseq : :: std :: os :: raw :: c_ulonglong , pub __wseq32 : __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 { pub __low : :: std :: os :: raw :: c_uint , pub __high : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . __low as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( __low ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . __high as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( __high ) ) ) ; } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_1 > ( ) ) ) . __wseq as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) , "::" , stringify ! ( __wseq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_1 > ( ) ) ) . __wseq32 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_1 ) , "::" , stringify ! ( __wseq32 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __pthread_cond_s__bindgen_ty_2 { pub __g1_start : :: std :: os :: raw :: c_ulonglong , pub __g1_start32 : __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 { pub __low : :: std :: os :: raw :: c_uint , pub __high : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) ) ) . __low as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! ( __low ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) ) ) . __high as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! ( __high ) ) ) ; } # [ test ] fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_2 > ( ) ) ) . __g1_start as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) , "::" , stringify ! ( __g1_start ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_2 > ( ) ) ) . __g1_start32 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s__bindgen_ty_2 ) , "::" , stringify ! ( __g1_start32 ) ) ) ; } # [ test ] fn bindgen_test_layout___pthread_cond_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cond_s > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( __pthread_cond_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cond_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cond_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s > ( ) ) ) . __g_refs as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g_refs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s > ( ) ) ) . __g_size as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s > ( ) ) ) . __g1_orig_size as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g1_orig_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s > ( ) ) ) . __wrefs as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __wrefs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cond_s > ( ) ) ) . __g_signals as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cond_s ) , "::" , stringify ! ( __g_signals ) ) ) ; } pub type pthread_t = :: std :: os :: raw :: c_ulong ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutexattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_mutexattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutexattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutexattr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutexattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutexattr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutexattr_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_condattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_condattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_condattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_condattr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_condattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_condattr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_condattr_t ) , "::" , stringify ! ( __align ) ) ) ; } pub type pthread_key_t = :: std :: os :: raw :: c_uint ; pub type pthread_once_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_attr_t { pub __size : [ :: std :: os :: raw :: c_char ; 56usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 7usize ] , } # [ test ] fn bindgen_test_layout_pthread_attr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_attr_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_attr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_attr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_attr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_attr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_attr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutex_t { pub __data : __pthread_mutex_s , pub __size : [ :: std :: os :: raw :: c_char ; 40usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 5usize ] , } # [ test ] fn bindgen_test_layout_pthread_mutex_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutex_t > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutex_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t > ( ) ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_cond_t { pub __data : __pthread_cond_s , pub __size : [ :: std :: os :: raw :: c_char ; 48usize ] , pub __align : :: std :: os :: raw :: c_longlong , _bindgen_union_align : [ u64 ; 6usize ] , } # [ test ] fn bindgen_test_layout_pthread_cond_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_cond_t > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_cond_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t > ( ) ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlock_t { pub __data : __pthread_rwlock_arch_t , pub __size : [ :: std :: os :: raw :: c_char ; 56usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 7usize ] , } # [ test ] fn bindgen_test_layout_pthread_rwlock_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlock_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlock_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlock_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t > ( ) ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlockattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 8usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_pthread_rwlockattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlockattr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlockattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlockattr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlockattr_t ) , "::" , stringify ! ( __align ) ) ) ; } pub type pthread_spinlock_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrier_t { pub __size : [ :: std :: os :: raw :: c_char ; 32usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 4usize ] , } # [ test ] fn bindgen_test_layout_pthread_barrier_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrier_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( pthread_barrier_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrier_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_barrier_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_barrier_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_barrier_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_barrier_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrierattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_barrierattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrierattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_barrierattr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_barrierattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_barrierattr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_barrierattr_t ) , "::" , stringify ! ( __align ) ) ) ; } pub type __jmp_buf = [ :: std :: os :: raw :: c_long ; 8usize ] ; pub const PTHREAD_CREATE_JOINABLE : _bindgen_ty_1 = 0 ; pub const PTHREAD_CREATE_DETACHED : _bindgen_ty_1 = 1 ; pub type _bindgen_ty_1 = u32 ; pub const PTHREAD_MUTEX_TIMED_NP : _bindgen_ty_2 = 0 ; pub const PTHREAD_MUTEX_RECURSIVE_NP : _bindgen_ty_2 = 1 ; pub const PTHREAD_MUTEX_ERRORCHECK_NP : _bindgen_ty_2 = 2 ; pub const PTHREAD_MUTEX_ADAPTIVE_NP : _bindgen_ty_2 = 3 ; pub const PTHREAD_MUTEX_NORMAL : _bindgen_ty_2 = 0 ; pub const PTHREAD_MUTEX_RECURSIVE : _bindgen_ty_2 = 1 ; pub const PTHREAD_MUTEX_ERRORCHECK : _bindgen_ty_2 = 2 ; pub const PTHREAD_MUTEX_DEFAULT : _bindgen_ty_2 = 0 ; pub type _bindgen_ty_2 = u32 ; pub const PTHREAD_MUTEX_STALLED : _bindgen_ty_3 = 0 ; pub const PTHREAD_MUTEX_STALLED_NP : _bindgen_ty_3 = 0 ; pub const PTHREAD_MUTEX_ROBUST : _bindgen_ty_3 = 1 ; pub const PTHREAD_MUTEX_ROBUST_NP : _bindgen_ty_3 = 1 ; pub type _bindgen_ty_3 = u32 ; pub const PTHREAD_PRIO_NONE : _bindgen_ty_4 = 0 ; pub const PTHREAD_PRIO_INHERIT : _bindgen_ty_4 = 1 ; pub const PTHREAD_PRIO_PROTECT : _bindgen_ty_4 = 2 ; pub type _bindgen_ty_4 = u32 ; pub const PTHREAD_RWLOCK_PREFER_READER_NP : _bindgen_ty_5 = 0 ; pub const PTHREAD_RWLOCK_PREFER_WRITER_NP : _bindgen_ty_5 = 1 ; pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP : _bindgen_ty_5 = 2 ; pub const PTHREAD_RWLOCK_DEFAULT_NP : _bindgen_ty_5 = 0 ; pub type _bindgen_ty_5 = u32 ; pub const PTHREAD_INHERIT_SCHED : _bindgen_ty_6 = 0 ; pub const PTHREAD_EXPLICIT_SCHED : _bindgen_ty_6 = 1 ; pub type _bindgen_ty_6 = u32 ; pub const PTHREAD_SCOPE_SYSTEM : _bindgen_ty_7 = 0 ; pub const PTHREAD_SCOPE_PROCESS : _bindgen_ty_7 = 1 ; pub type _bindgen_ty_7 = u32 ; pub const PTHREAD_PROCESS_PRIVATE : _bindgen_ty_8 = 0 ; pub const PTHREAD_PROCESS_SHARED : _bindgen_ty_8 = 1 ; pub type _bindgen_ty_8 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _pthread_cleanup_buffer { pub __routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) > , pub __arg : * mut :: std :: os :: raw :: c_void , pub __canceltype : :: std :: os :: raw :: c_int , pub __prev : * mut _pthread_cleanup_buffer , } # [ test ] fn bindgen_test_layout__pthread_cleanup_buffer ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _pthread_cleanup_buffer > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( _pthread_cleanup_buffer ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _pthread_cleanup_buffer > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _pthread_cleanup_buffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _pthread_cleanup_buffer > ( ) ) ) . __routine as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _pthread_cleanup_buffer ) , "::" , stringify ! ( __routine ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _pthread_cleanup_buffer > ( ) ) ) . __arg as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _pthread_cleanup_buffer ) , "::" , stringify ! ( __arg ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _pthread_cleanup_buffer > ( ) ) ) . __canceltype as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _pthread_cleanup_buffer ) , "::" , stringify ! ( __canceltype ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _pthread_cleanup_buffer > ( ) ) ) . __prev as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _pthread_cleanup_buffer ) , "::" , stringify ! ( __prev ) ) ) ; } pub const PTHREAD_CANCEL_ENABLE : _bindgen_ty_9 = 0 ; pub const PTHREAD_CANCEL_DISABLE : _bindgen_ty_9 = 1 ; pub type _bindgen_ty_9 = u32 ; pub const PTHREAD_CANCEL_DEFERRED : _bindgen_ty_10 = 0 ; pub const PTHREAD_CANCEL_ASYNCHRONOUS : _bindgen_ty_10 = 1 ; pub type _bindgen_ty_10 = u32 ; extern "C" { pub fn pthread_create ( __newthread : * mut pthread_t , __attr : * const pthread_attr_t , __start_routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) -> * mut :: std :: os :: raw :: c_void > , __arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_exit ( __retval : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { pub fn pthread_join ( __th : pthread_t , __thread_return : * mut * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_detach ( __th : pthread_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_self ( ) -> pthread_t ; } extern "C" { pub fn pthread_equal ( __thread1 : pthread_t , __thread2 : pthread_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_init ( __attr : * mut pthread_attr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_destroy ( __attr : * mut pthread_attr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_getdetachstate ( __attr : * const pthread_attr_t , __detachstate : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_setdetachstate ( __attr : * mut pthread_attr_t , __detachstate : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_getguardsize ( __attr : * const pthread_attr_t , __guardsize : * mut usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_setguardsize ( __attr : * mut pthread_attr_t , __guardsize : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_getschedparam ( __attr : * const pthread_attr_t , __param : * mut sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_setschedparam ( __attr : * mut pthread_attr_t , __param : * const sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_getschedpolicy ( __attr : * const pthread_attr_t , __policy : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_setschedpolicy ( __attr : * mut pthread_attr_t , __policy : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_getinheritsched ( __attr : * const pthread_attr_t , __inherit : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_setinheritsched ( __attr : * mut pthread_attr_t , __inherit : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_getscope ( __attr : * const pthread_attr_t , __scope : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_setscope ( __attr : * mut pthread_attr_t , __scope : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_getstackaddr ( __attr : * const pthread_attr_t , __stackaddr : * mut * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_setstackaddr ( __attr : * mut pthread_attr_t , __stackaddr : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_getstacksize ( __attr : * const pthread_attr_t , __stacksize : * mut usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_setstacksize ( __attr : * mut pthread_attr_t , __stacksize : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_getstack ( __attr : * const pthread_attr_t , __stackaddr : * mut * mut :: std :: os :: raw :: c_void , __stacksize : * mut usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_attr_setstack ( __attr : * mut pthread_attr_t , __stackaddr : * mut :: std :: os :: raw :: c_void , __stacksize : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_setschedparam ( __target_thread : pthread_t , __policy : :: std :: os :: raw :: c_int , __param : * const sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_getschedparam ( __target_thread : pthread_t , __policy : * mut :: std :: os :: raw :: c_int , __param : * mut sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_setschedprio ( __target_thread : pthread_t , __prio : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_once ( __once_control : * mut pthread_once_t , __init_routine : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_setcancelstate ( __state : :: std :: os :: raw :: c_int , __oldstate : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_setcanceltype ( __type : :: std :: os :: raw :: c_int , __oldtype : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_cancel ( __th : pthread_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_testcancel ( ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_unwind_buf_t { pub __cancel_jmp_buf : [ __pthread_unwind_buf_t__bindgen_ty_1 ; 1usize ] , pub __pad : [ * mut :: std :: os :: raw :: c_void ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_unwind_buf_t__bindgen_ty_1 { pub __cancel_jmp_buf : __jmp_buf , pub __mask_was_saved : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_unwind_buf_t__bindgen_ty_1 > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( __pthread_unwind_buf_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_unwind_buf_t__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_unwind_buf_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_unwind_buf_t__bindgen_ty_1 > ( ) ) ) . __cancel_jmp_buf as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_unwind_buf_t__bindgen_ty_1 ) , "::" , stringify ! ( __cancel_jmp_buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_unwind_buf_t__bindgen_ty_1 > ( ) ) ) . __mask_was_saved as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_unwind_buf_t__bindgen_ty_1 ) , "::" , stringify ! ( __mask_was_saved ) ) ) ; } # [ test ] fn bindgen_test_layout___pthread_unwind_buf_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_unwind_buf_t > ( ) , 104usize , concat ! ( "Size of: " , stringify ! ( __pthread_unwind_buf_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_unwind_buf_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_unwind_buf_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_unwind_buf_t > ( ) ) ) . __cancel_jmp_buf as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_unwind_buf_t ) , "::" , stringify ! ( __cancel_jmp_buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_unwind_buf_t > ( ) ) ) . __pad as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_unwind_buf_t ) , "::" , stringify ! ( __pad ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_cleanup_frame { pub __cancel_routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) > , pub __cancel_arg : * mut :: std :: os :: raw :: c_void , pub __do_it : :: std :: os :: raw :: c_int , pub __cancel_type : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout___pthread_cleanup_frame ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cleanup_frame > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __pthread_cleanup_frame ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cleanup_frame > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cleanup_frame ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cleanup_frame > ( ) ) ) . __cancel_routine as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cleanup_frame ) , "::" , stringify ! ( __cancel_routine ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cleanup_frame > ( ) ) ) . __cancel_arg as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cleanup_frame ) , "::" , stringify ! ( __cancel_arg ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cleanup_frame > ( ) ) ) . __do_it as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cleanup_frame ) , "::" , stringify ! ( __do_it ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_cleanup_frame > ( ) ) ) . __cancel_type as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_cleanup_frame ) , "::" , stringify ! ( __cancel_type ) ) ) ; } extern "C" { pub fn __pthread_register_cancel ( __buf : * mut __pthread_unwind_buf_t ) ; } extern "C" { pub fn __pthread_unregister_cancel ( __buf : * mut __pthread_unwind_buf_t ) ; } extern "C" { pub fn __pthread_unwind_next ( __buf : * mut __pthread_unwind_buf_t ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __jmp_buf_tag { _unused : [ u8 ; 0 ] , } extern "C" { pub fn __sigsetjmp ( __env : * mut __jmp_buf_tag , __savemask : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutex_init ( __mutex : * mut pthread_mutex_t , __mutexattr : * const pthread_mutexattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutex_destroy ( __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutex_trylock ( __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutex_lock ( __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutex_timedlock ( __mutex : * mut pthread_mutex_t , __abstime : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutex_unlock ( __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutex_getprioceiling ( __mutex : * const pthread_mutex_t , __prioceiling : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutex_setprioceiling ( __mutex : * mut pthread_mutex_t , __prioceiling : :: std :: os :: raw :: c_int , __old_ceiling : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutex_consistent ( __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutexattr_init ( __attr : * mut pthread_mutexattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutexattr_destroy ( __attr : * mut pthread_mutexattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutexattr_getpshared ( __attr : * const pthread_mutexattr_t , __pshared : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutexattr_setpshared ( __attr : * mut pthread_mutexattr_t , __pshared : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutexattr_gettype ( __attr : * const pthread_mutexattr_t , __kind : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutexattr_settype ( __attr : * mut pthread_mutexattr_t , __kind : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutexattr_getprotocol ( __attr : * const pthread_mutexattr_t , __protocol : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutexattr_setprotocol ( __attr : * mut pthread_mutexattr_t , __protocol : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutexattr_getprioceiling ( __attr : * const pthread_mutexattr_t , __prioceiling : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutexattr_setprioceiling ( __attr : * mut pthread_mutexattr_t , __prioceiling : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutexattr_getrobust ( __attr : * const pthread_mutexattr_t , __robustness : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_mutexattr_setrobust ( __attr : * mut pthread_mutexattr_t , __robustness : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_rwlock_init ( __rwlock : * mut pthread_rwlock_t , __attr : * const pthread_rwlockattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_rwlock_destroy ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_rwlock_rdlock ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_rwlock_tryrdlock ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_rwlock_timedrdlock ( __rwlock : * mut pthread_rwlock_t , __abstime : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_rwlock_wrlock ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_rwlock_trywrlock ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_rwlock_timedwrlock ( __rwlock : * mut pthread_rwlock_t , __abstime : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_rwlock_unlock ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_rwlockattr_init ( __attr : * mut pthread_rwlockattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_rwlockattr_destroy ( __attr : * mut pthread_rwlockattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_rwlockattr_getpshared ( __attr : * const pthread_rwlockattr_t , __pshared : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_rwlockattr_setpshared ( __attr : * mut pthread_rwlockattr_t , __pshared : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_rwlockattr_getkind_np ( __attr : * const pthread_rwlockattr_t , __pref : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_rwlockattr_setkind_np ( __attr : * mut pthread_rwlockattr_t , __pref : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_cond_init ( __cond : * mut pthread_cond_t , __cond_attr : * const pthread_condattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_cond_destroy ( __cond : * mut pthread_cond_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_cond_signal ( __cond : * mut pthread_cond_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_cond_broadcast ( __cond : * mut pthread_cond_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_cond_wait ( __cond : * mut pthread_cond_t , __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_cond_timedwait ( __cond : * mut pthread_cond_t , __mutex : * mut pthread_mutex_t , __abstime : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_condattr_init ( __attr : * mut pthread_condattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_condattr_destroy ( __attr : * mut pthread_condattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_condattr_getpshared ( __attr : * const pthread_condattr_t , __pshared : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_condattr_setpshared ( __attr : * mut pthread_condattr_t , __pshared : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_condattr_getclock ( __attr : * const pthread_condattr_t , __clock_id : * mut __clockid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_condattr_setclock ( __attr : * mut pthread_condattr_t , __clock_id : __clockid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_spin_init ( __lock : * mut pthread_spinlock_t , __pshared : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_spin_destroy ( __lock : * mut pthread_spinlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_spin_lock ( __lock : * mut pthread_spinlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_spin_trylock ( __lock : * mut pthread_spinlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_spin_unlock ( __lock : * mut pthread_spinlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_barrier_init ( __barrier : * mut pthread_barrier_t , __attr : * const pthread_barrierattr_t , __count : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_barrier_destroy ( __barrier : * mut pthread_barrier_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_barrier_wait ( __barrier : * mut pthread_barrier_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_barrierattr_init ( __attr : * mut pthread_barrierattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_barrierattr_destroy ( __attr : * mut pthread_barrierattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_barrierattr_getpshared ( __attr : * const pthread_barrierattr_t , __pshared : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_barrierattr_setpshared ( __attr : * mut pthread_barrierattr_t , __pshared : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_key_create ( __key : * mut pthread_key_t , __destr_function : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) > ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_key_delete ( __key : pthread_key_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_getspecific ( __key : pthread_key_t ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn pthread_setspecific ( __key : pthread_key_t , __pointer : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_getcpuclockid ( __thread_id : pthread_t , __clock_id : * mut __clockid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pthread_atfork ( __prepare : :: std :: option :: Option < unsafe extern "C" fn ( ) > , __parent : :: std :: option :: Option < unsafe extern "C" fn ( ) > , __child : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ht_pthread_mapped_tracepoint_enter ( timeline : * mut HT_Timeline , label : * const :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn ht_pthread_mapped_tracepoint_leave ( ) ; } extern "C" { pub fn ht_pthread_mapped_tracepoint_add_mapping ( ) ; } extern "C" { pub fn _ht_posix_mapped_tracepoint_init ( ) ; } extern "C" { pub fn _ht_posix_mapped_tracepoint_deinit ( ) ; } extern "C" { pub fn ht_global_timeline_get ( ) -> * mut HT_Timeline ; } extern "C" { 
 /// Initializes HawkTracer library.
///
/// This function must be called before any other function
/// from this library. The only exception is ht_allocator_set(),
/// which must be called before ht_init().
///
/// @param argc a number of arguments of the @a argv array.
/// @param argv an array of strings - arguments for HawkTracer library. 
 pub fn ht_init ( argc : :: std :: os :: raw :: c_int , argv : * mut * mut :: std :: os :: raw :: c_char ) ; } extern "C" { 
 /// Uninitializes HawkTracer library.
///
/// This function must be called as a last function
/// of the library in the program. The only exception is
/// ht_timeline_deinit() which might be called after ht_deinit(),
/// however, it's highly not recommended and should be avoided
/// when possible. 
 pub fn ht_deinit ( ) ; } pub type __FILE = _IO_FILE ; pub type FILE = _IO_FILE ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __mbstate_t { pub __count : :: std :: os :: raw :: c_int , pub __value : __mbstate_t__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __mbstate_t__bindgen_ty_1 { pub __wch : :: std :: os :: raw :: c_uint , pub __wchb : [ :: std :: os :: raw :: c_char ; 4usize ] , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout___mbstate_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t__bindgen_ty_1 > ( ) ) ) . __wch as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t__bindgen_ty_1 > ( ) ) ) . __wchb as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb ) ) ) ; } # [ test ] fn bindgen_test_layout___mbstate_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __mbstate_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __mbstate_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __mbstate_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __mbstate_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t > ( ) ) ) . __count as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t ) , "::" , stringify ! ( __count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t > ( ) ) ) . __value as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t ) , "::" , stringify ! ( __value ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _G_fpos_t { pub __pos : __off_t , pub __state : __mbstate_t , } # [ test ] fn bindgen_test_layout__G_fpos_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _G_fpos_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _G_fpos_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _G_fpos_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _G_fpos_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _G_fpos_t > ( ) ) ) . __pos as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _G_fpos_t ) , "::" , stringify ! ( __pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _G_fpos_t > ( ) ) ) . __state as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _G_fpos_t ) , "::" , stringify ! ( __state ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _G_fpos64_t { pub __pos : __off64_t , pub __state : __mbstate_t , } # [ test ] fn bindgen_test_layout__G_fpos64_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _G_fpos64_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _G_fpos64_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _G_fpos64_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _G_fpos64_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _G_fpos64_t > ( ) ) ) . __pos as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _G_fpos64_t ) , "::" , stringify ! ( __pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _G_fpos64_t > ( ) ) ) . __state as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _G_fpos64_t ) , "::" , stringify ! ( __state ) ) ) ; } pub type va_list = __builtin_va_list ; pub type __gnuc_va_list = __builtin_va_list ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_jump_t { _unused : [ u8 ; 0 ] , } pub type _IO_lock_t = :: std :: os :: raw :: c_void ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_marker { pub _next : * mut _IO_marker , pub _sbuf : * mut _IO_FILE , pub _pos : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout__IO_marker ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _IO_marker > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( _IO_marker ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _IO_marker > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _IO_marker ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_marker > ( ) ) ) . _next as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _next ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_marker > ( ) ) ) . _sbuf as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _sbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_marker > ( ) ) ) . _pos as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _pos ) ) ) ; } pub const __codecvt_result___codecvt_ok : __codecvt_result = 0 ; pub const __codecvt_result___codecvt_partial : __codecvt_result = 1 ; pub const __codecvt_result___codecvt_error : __codecvt_result = 2 ; pub const __codecvt_result___codecvt_noconv : __codecvt_result = 3 ; pub type __codecvt_result = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_FILE { pub _flags : :: std :: os :: raw :: c_int , pub _IO_read_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_read_end : * mut :: std :: os :: raw :: c_char , pub _IO_read_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_write_end : * mut :: std :: os :: raw :: c_char , pub _IO_buf_base : * mut :: std :: os :: raw :: c_char , pub _IO_buf_end : * mut :: std :: os :: raw :: c_char , pub _IO_save_base : * mut :: std :: os :: raw :: c_char , pub _IO_backup_base : * mut :: std :: os :: raw :: c_char , pub _IO_save_end : * mut :: std :: os :: raw :: c_char , pub _markers : * mut _IO_marker , pub _chain : * mut _IO_FILE , pub _fileno : :: std :: os :: raw :: c_int , pub _flags2 : :: std :: os :: raw :: c_int , pub _old_offset : __off_t , pub _cur_column : :: std :: os :: raw :: c_ushort , pub _vtable_offset : :: std :: os :: raw :: c_schar , pub _shortbuf : [ :: std :: os :: raw :: c_char ; 1usize ] , pub _lock : * mut _IO_lock_t , pub _offset : __off64_t , pub __pad1 : * mut :: std :: os :: raw :: c_void , pub __pad2 : * mut :: std :: os :: raw :: c_void , pub __pad3 : * mut :: std :: os :: raw :: c_void , pub __pad4 : * mut :: std :: os :: raw :: c_void , pub __pad5 : usize , pub _mode : :: std :: os :: raw :: c_int , pub _unused2 : [ :: std :: os :: raw :: c_char ; 20usize ] , } # [ test ] fn bindgen_test_layout__IO_FILE ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _IO_FILE > ( ) , 216usize , concat ! ( "Size of: " , stringify ! ( _IO_FILE ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _IO_FILE > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _IO_FILE ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _flags as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_read_ptr as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_read_end as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_read_base as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_write_base as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_write_ptr as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_write_end as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_buf_base as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_buf_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_buf_end as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_buf_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_save_base as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_save_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_backup_base as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_backup_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_save_end as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_save_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _markers as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _markers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _chain as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _chain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _fileno as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _fileno ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _flags2 as * const _ as usize } , 116usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _flags2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _old_offset as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _old_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _cur_column as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _cur_column ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _vtable_offset as * const _ as usize } , 130usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _vtable_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _shortbuf as * const _ as usize } , 131usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _shortbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _lock as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _offset as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad1 as * const _ as usize } , 152usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad2 as * const _ as usize } , 160usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad3 as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad4 as * const _ as usize } , 176usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad5 as * const _ as usize } , 184usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _mode as * const _ as usize } , 192usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _mode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _unused2 as * const _ as usize } , 196usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _unused2 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_FILE_plus { _unused : [ u8 ; 0 ] , } extern "C" { # [ link_name = "\u{1}_IO_2_1_stdin_" ] pub static mut _IO_2_1_stdin_ : _IO_FILE_plus ; } extern "C" { # [ link_name = "\u{1}_IO_2_1_stdout_" ] pub static mut _IO_2_1_stdout_ : _IO_FILE_plus ; } extern "C" { # [ link_name = "\u{1}_IO_2_1_stderr_" ] pub static mut _IO_2_1_stderr_ : _IO_FILE_plus ; } pub type __io_read_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __buf : * mut :: std :: os :: raw :: c_char , __nbytes : usize ) -> __ssize_t > ; pub type __io_write_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __buf : * const :: std :: os :: raw :: c_char , __n : usize ) -> __ssize_t > ; pub type __io_seek_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __pos : * mut __off64_t , __w : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > ; pub type __io_close_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; extern "C" { pub fn __underflow ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __uflow ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __overflow ( arg1 : * mut _IO_FILE , arg2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_getc ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_putc ( __c : :: std :: os :: raw :: c_int , __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_feof ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_ferror ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_peekc_locked ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_flockfile ( arg1 : * mut _IO_FILE ) ; } extern "C" { pub fn _IO_funlockfile ( arg1 : * mut _IO_FILE ) ; } extern "C" { pub fn _IO_ftrylockfile ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_vfscanf ( arg1 : * mut _IO_FILE , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut __va_list_tag , arg4 : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_vfprintf ( arg1 : * mut _IO_FILE , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_padn ( arg1 : * mut _IO_FILE , arg2 : :: std :: os :: raw :: c_int , arg3 : __ssize_t ) -> __ssize_t ; } extern "C" { pub fn _IO_sgetn ( arg1 : * mut _IO_FILE , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : usize ) -> usize ; } extern "C" { pub fn _IO_seekoff ( arg1 : * mut _IO_FILE , arg2 : __off64_t , arg3 : :: std :: os :: raw :: c_int , arg4 : :: std :: os :: raw :: c_int ) -> __off64_t ; } extern "C" { pub fn _IO_seekpos ( arg1 : * mut _IO_FILE , arg2 : __off64_t , arg3 : :: std :: os :: raw :: c_int ) -> __off64_t ; } extern "C" { pub fn _IO_free_backup_area ( arg1 : * mut _IO_FILE ) ; } pub type off_t = __off_t ; pub type fpos_t = _G_fpos_t ; extern "C" { # [ link_name = "\u{1}stdin" ] pub static mut stdin : * mut _IO_FILE ; } extern "C" { # [ link_name = "\u{1}stdout" ] pub static mut stdout : * mut _IO_FILE ; } extern "C" { # [ link_name = "\u{1}stderr" ] pub static mut stderr : * mut _IO_FILE ; } extern "C" { pub fn remove ( __filename : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn rename ( __old : * const :: std :: os :: raw :: c_char , __new : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn renameat ( __oldfd : :: std :: os :: raw :: c_int , __old : * const :: std :: os :: raw :: c_char , __newfd : :: std :: os :: raw :: c_int , __new : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn tmpfile ( ) -> * mut FILE ; } extern "C" { pub fn tmpnam ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn tmpnam_r ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn tempnam ( __dir : * const :: std :: os :: raw :: c_char , __pfx : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn fclose ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fflush ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fflush_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fopen ( __filename : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn freopen ( __filename : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char , __stream : * mut FILE ) -> * mut FILE ; } extern "C" { pub fn fdopen ( __fd : :: std :: os :: raw :: c_int , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn fmemopen ( __s : * mut :: std :: os :: raw :: c_void , __len : usize , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn open_memstream ( __bufloc : * mut * mut :: std :: os :: raw :: c_char , __sizeloc : * mut usize ) -> * mut FILE ; } extern "C" { pub fn setbuf ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn setvbuf ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char , __modes : :: std :: os :: raw :: c_int , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setbuffer ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char , __size : usize ) ; } extern "C" { pub fn setlinebuf ( __stream : * mut FILE ) ; } extern "C" { pub fn fprintf ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn printf ( __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sprintf ( __s : * mut :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vfprintf ( __s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vprintf ( __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vsprintf ( __s : * mut :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn snprintf ( __s : * mut :: std :: os :: raw :: c_char , __maxlen : usize , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vsnprintf ( __s : * mut :: std :: os :: raw :: c_char , __maxlen : usize , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vdprintf ( __fd : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn dprintf ( __fd : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fscanf ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn scanf ( __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sscanf ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_fscanf" ] pub fn fscanf1 ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_scanf" ] pub fn scanf1 ( __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_sscanf" ] pub fn sscanf1 ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vfscanf ( __s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vscanf ( __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vsscanf ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_vfscanf" ] pub fn vfscanf1 ( __s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_vscanf" ] pub fn vscanf1 ( __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_vsscanf" ] pub fn vsscanf1 ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgetc ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getc ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getchar ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getc_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getchar_unlocked ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgetc_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fputc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putchar ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fputc_unlocked ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putc_unlocked ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putchar_unlocked ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getw ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putw ( __w : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgets ( __s : * mut :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __getdelim ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __delimiter : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn getdelim ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __delimiter : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn getline ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn fputs ( __s : * const :: std :: os :: raw :: c_char , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn puts ( __s : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ungetc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fread ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fwrite ( __ptr : * const :: std :: os :: raw :: c_void , __size : usize , __n : usize , __s : * mut FILE ) -> usize ; } extern "C" { pub fn fread_unlocked ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fwrite_unlocked ( __ptr : * const :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fseek ( __stream : * mut FILE , __off : :: std :: os :: raw :: c_long , __whence : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ftell ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn rewind ( __stream : * mut FILE ) ; } extern "C" { pub fn fseeko ( __stream : * mut FILE , __off : __off_t , __whence : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ftello ( __stream : * mut FILE ) -> __off_t ; } extern "C" { pub fn fgetpos ( __stream : * mut FILE , __pos : * mut fpos_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fsetpos ( __stream : * mut FILE , __pos : * const fpos_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn clearerr ( __stream : * mut FILE ) ; } extern "C" { pub fn feof ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ferror ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn clearerr_unlocked ( __stream : * mut FILE ) ; } extern "C" { pub fn feof_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ferror_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn perror ( __s : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}sys_nerr" ] pub static mut sys_nerr : :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}sys_errlist" ] pub static mut sys_errlist : [ * const :: std :: os :: raw :: c_char ; 0usize ] ; } extern "C" { pub fn fileno ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fileno_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn popen ( __command : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn pclose ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ctermid ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn flockfile ( __stream : * mut FILE ) ; } extern "C" { pub fn ftrylockfile ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn funlockfile ( __stream : * mut FILE ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _HT_FileDumpListener { _unused : [ u8 ; 0 ] , } pub type HT_FileDumpListener = _HT_FileDumpListener ; extern "C" { pub fn ht_file_dump_listener_create ( filename : * const :: std :: os :: raw :: c_char , buffer_size : usize , out_err : * mut HT_ErrorCode ) -> * mut HT_FileDumpListener ; } extern "C" { pub fn ht_file_dump_listener_destroy ( listener : * mut HT_FileDumpListener ) ; } extern "C" { pub fn ht_file_dump_listener_callback ( events : TEventPtr , size : usize , serialized : HT_Boolean , user_data : * mut :: std :: os :: raw :: c_void ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _HT_TCPListener { _unused : [ u8 ; 0 ] , } pub type HT_TCPListener = _HT_TCPListener ; extern "C" { pub fn ht_tcp_listener_create ( port : :: std :: os :: raw :: c_int , buffer_size : usize , out_err : * mut HT_ErrorCode ) -> * mut HT_TCPListener ; } extern "C" { pub fn ht_tcp_listener_destroy ( listener : * mut HT_TCPListener ) ; } extern "C" { pub fn ht_tcp_listener_callback ( events : TEventPtr , size : usize , serialized : HT_Boolean , user_data : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { pub fn ht_system_info_get_endianness ( ) -> HT_Endianness ; } extern "C" { pub fn ht_system_info_push_endianness_info_to_listener ( callback : HT_TimelineListenerCallback , listener : * mut :: std :: os :: raw :: c_void , serialize : HT_Boolean ) -> usize ; } extern "C" { pub fn ht_system_info_push_system_info_to_listener ( callback : HT_TimelineListenerCallback , listener : * mut :: std :: os :: raw :: c_void , serialize : HT_Boolean ) -> usize ; } 
 /// A task scheduler's callback. 
 pub type HT_TaskCallback = :: std :: option :: Option < unsafe extern "C" fn ( user_data : * mut :: std :: os :: raw :: c_void ) > ; 
 /// A task scheduler's task identifier. 
 pub type HT_TaskId = i32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _HT_Task { _unused : [ u8 ; 0 ] , } pub type HT_Task = _HT_Task ; 
 /// Ignores task execution delays; if the task has been run after the timeout,
/// next task execution will be performed according to a schedule
/// (so it won't be affected by a previous delay). 
 pub const HT_TaskSchedulingMode_HT_TASK_SCHEDULING_IGNORE_DELAYS : HT_TaskSchedulingMode = 0 ; 
 /// Takes delays into account, and restarts the timer for the task after its execution;
/// if task was delayed, next task will be executed after a @b period time of the previous
/// execution. 
 pub const HT_TaskSchedulingMode_HT_TASK_SCHEDULING_RESTART_TIMER : HT_TaskSchedulingMode = 1 ; 
 /// Task scheduling mode. 
 pub type HT_TaskSchedulingMode = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _HT_TaskScheduler { _unused : [ u8 ; 0 ] , } pub type HT_TaskScheduler = _HT_TaskScheduler ; extern "C" { 
 /// Creates an instance of the HT_TaskScheduler structure.
///
/// @param out_err #HT_ERR_OK, if creation completed succesfully; otherwise, appropriate error code.
///
/// @return task_scheduler a pointer to the scheduler, or NULL if create failed. 
 pub fn ht_task_scheduler_create ( out_err : * mut HT_ErrorCode ) -> * mut HT_TaskScheduler ; } extern "C" { 
 /// Destroys task scheduler data structure.
///
/// @param task_scheduler a pointer to the scheduler. 
 pub fn ht_task_scheduler_destroy ( task_scheduler : * mut HT_TaskScheduler ) ; } extern "C" { 
 /// Adds a new task to a scheduler.
/// @param task_scheduler a pointer to the scheduler.
/// @param mode a task scheduling mode. @sa HT_TaskSchedulingMode
/// @param period a minimum time (in nanoseconds) between two executions of the task.
/// @param callback a task's function. Can not be NULL.
/// @param user_data a pointer to a data which is passed to a callback when executed.
///
/// @return a unique identifier of the task if the task is scheduled successfully; otherwise
/// #HT_TASK_SCHEDULER_INVALID_TASK_ID. 
 pub fn ht_task_scheduler_schedule_task ( task_scheduler : * mut HT_TaskScheduler , mode : HT_TaskSchedulingMode , period : HT_DurationNs , callback : HT_TaskCallback , user_data : * mut :: std :: os :: raw :: c_void ) -> HT_TaskId ; } extern "C" { 
 /// Deletes a task from a scheduler.
///
/// @param task_scheduler a pointer to the scheduler.
/// @param task_id an identifier of the task to remove.
///
/// @return #HT_TRUE, if task was removed successfully; if task doesn't exist, returns #HT_FALSE. 
 pub fn ht_task_scheduler_remove_task ( task_scheduler : * mut HT_TaskScheduler , task_id : HT_TaskId ) -> HT_Boolean ; } extern "C" { 
 /// Executes scheduled tasks when they time out.
///
/// @param task_scheduler a pointer to the scheduler. 
 pub fn ht_task_scheduler_tick ( task_scheduler : * mut HT_TaskScheduler ) ; } extern "C" { 
 /// Gets optimal tick period for scheduled tasks.
/// The function returns the greatest common divisor of all task periods.
/// E.g. for following periods of scheduled tasks: (10, 15, 25), optimal tick period is 5.
///
/// @note This function ignores tasks with period equal to 0. Therefore optimal tick period
/// for task periods: (10, 15, 25, 0) is still 5.
///
/// @param task_scheduler a pointer to the scheduler.
///
/// @return optimal tick period. 
 pub fn ht_task_scheduler_get_optimal_tick_period ( task_scheduler : * mut HT_TaskScheduler ) -> HT_DurationNs ; } extern "C" { 
 /// Gets a unique identifier of the current thread.
///
/// @return an identifier of the current thread. 
 pub fn ht_thread_get_current_thread_id ( ) -> HT_ThreadId ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _HT_CPUUsageContext { _unused : [ u8 ; 0 ] , } 
 /// A forward declaration for CPU Usage context. This structure
/// should be defined in the implementation file. 
 pub type HT_CPUUsageContext = _HT_CPUUsageContext ; extern "C" { 
 /// Creates a context for a CPU usage feature.
/// This context is used for getting percentage CPU usage, and the
/// structure is platform specific. The context should always be
/// destroyed using ht_cpu_usage_context_destroy().
///
/// @param process_id a platform specific description of process ID,
/// or NULL to get CPU usage of the current process.
/// For linux-based platforms, it should be a pointer to a variable
/// of type integer (int), which holds the process ID.
///
/// @return the CPU Usage context. 
 pub fn ht_cpu_usage_context_create ( process_id : * mut :: std :: os :: raw :: c_void ) -> * mut HT_CPUUsageContext ; } extern "C" { 
 /// Destroys CPU Usage context.
///
/// @param context a pointer to the context. 
 pub fn ht_cpu_usage_context_destroy ( context : * mut HT_CPUUsageContext ) ; } extern "C" { 
 /// Gets a CPU usage percentage for a process.
///
/// The process ID should be specified in ht_cpu_usage_context_create().
///
/// @param context a CPU Usage context.
///
/// @return a CPU usage percentage of a specified process, or negative
/// value on error. 
 pub fn ht_cpu_usage_get_percentage ( context : * mut HT_CPUUsageContext ) -> f32 ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _HT_MemoryUsageContext { _unused : [ u8 ; 0 ] , } 
 /// A forward declaration for memory usage context. This structure
/// should be defined in the implementation file. 
 pub type HT_MemoryUsageContext = _HT_MemoryUsageContext ; extern "C" { 
 /// Creates a context for a memory usage feature.
/// This context is used for getting memory usage, and the
/// structure is platform specific. The context should always be
/// destroyed using ht_memory_usage_context_destroy().
///
/// @param process_id a platform specific description of process ID,
/// or NULL to get memory usage of the current process.
/// For linux-based platforms, it should be a pointer to a variable
/// of type integer (int), which holds the process ID.
///
/// @return the memory usage context or NULL if the function failed to create a context. 
 pub fn ht_memory_usage_context_create ( process_id : * mut :: std :: os :: raw :: c_void ) -> * mut HT_MemoryUsageContext ; } extern "C" { 
 /// Destroys memory context.
///
/// @param context a pointer to the context. 
 pub fn ht_memory_usage_context_destroy ( context : * mut HT_MemoryUsageContext ) ; } extern "C" { 
 /// Gets a memory usage of the process in bytes.
///
/// @param context a memory usage context.
///
/// @param virtual_memory_bytes a pointer to a variable where virtual memory
/// used by the process will be stored, or NULL if the value should not be read.
/// @param shared_memory_bytes a pointer to a variable where shared memory
/// used by the process will be stored, or NULL if the value should not be read.
/// @param resident_memory_bytes a pointer to a variable where resident memory
/// used by the process will be stored, or NULL if the value should not be read.
///
/// @returns #HT_ERR_OK, if memory has been read succesfully; otherwise, appropriate error code. 
 pub fn ht_memory_usage_get_usage ( context : * mut HT_MemoryUsageContext , virtual_memory_bytes : * mut usize , shared_memory_bytes : * mut usize , resident_memory_bytes : * mut usize ) -> HT_ErrorCode ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __locale_data { pub _address : u8 , } pub type __builtin_va_list = [ __va_list_tag ; 1usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __va_list_tag { pub gp_offset : :: std :: os :: raw :: c_uint , pub fp_offset : :: std :: os :: raw :: c_uint , pub overflow_arg_area : * mut :: std :: os :: raw :: c_void , pub reg_save_area : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout___va_list_tag ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __va_list_tag > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __va_list_tag > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . gp_offset as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( gp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . fp_offset as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( fp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . overflow_arg_area as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( overflow_arg_area ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . reg_save_area as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( reg_save_area ) ) ) ; }